{"type":"data","nodes":[null,null,{"type":"data","data":[{"title":1,"html":2},"Design","\u003Ch1>D3FEND CAD\u003C/h1>\n\u003Cp>Basic design requirements for the D3FEND CAD tool.\u003C/p>\n\u003Ch2>CAD Graph Data Model\u003C/h2>\n\u003Cp>D3FEND CAD uses the svelte-flow library for graph visualization. Nearly all mature graph UI libraries have their own representations, especially on the web. Unfortunately, none really use semantic graph technology.\u003C/p>\n\u003Cp>As such, here is our JSON Schema data model:\u003C/p>\n\u003Cul>\n\u003Cli>\u003Ca href=\"/cad/docs/schema/\">D3FEND CAD Schema\u003C/a>\u003C/li>\n\u003C/ul>\n\u003Cblockquote>\n\u003Cp>Of note, there are separate data structures for &quot;nodes and edges&quot; in this schema, this is not a triple model. We have to translate this denormalized structure to a normalized one, RDF in our case. \u003C/p>\n\u003C/blockquote>\n\u003Cblockquote>\n\u003Cp>On the node and edge \u003Ccode>object\u003C/code>, there is a property \u003Ccode>d3f_iri\u003C/code>, this is used to translate between the schema and the D3FEND Ontology. This property is intended to work for both class instance and all property types.\u003C/p>\n\u003C/blockquote>\n\u003Ch2>CAD Graph to Semantic Graph Conversions\u003C/h2>\n\u003Cp>We handle two primary use cases when we convert from the CAD Graph to a D3FEND Semantic Graph.\u003C/p>\n\u003Col>\n\u003Cli>\u003Cp>\u003Cstrong>Instance focused semantic graph\u003C/strong>\u003C/p>\n\u003Cp> This is the primary use case for CAD. Users use the ontology as it exists to create ontologically consistent graphs of cyber threat scenarios, model CTI reports, and system security architectures designs. Additionally, these models will also be exportable to SysML or other systems engineering representations and D3FEND will serve as the &quot;Rosetta Stone&quot;. These advanced secondary conversions may exist as scripts outside of CAD.\u003C/p>\n\u003C/li>\n\u003Cli>\u003Cp>\u003Cstrong>D3FEND Ontology additions\u003C/strong>\u003C/p>\n\u003Cp> An import additional use case as the acceleration of accurate and precise additions to the D3FEND ontology. Users can specify a scenario, e.g. as they might in use case #1, and then specific additional classes, properties, and restrictions to add the missing elements they need to the D3FEND Ontology. The TTL conversion route will make certain assumptions about the intentions of the user. This will be a limited functionality focused on ontology additions, versus full ontology editing.\u003C/p>\n\u003Cp> \u003Cem>Behavior and interpretation logic:\u003C/em>\u003C/p>\n\u003Cpre>\u003Ccode>Class := Node\nProperty := Edge\n\u003C/code>\u003C/pre>\n\u003Cul>\n\u003Cli>If user prefixes a node or edge with a \u003Ccode>:\u003C/code>, then it is assumed to be new declaration of a class or property respectively.\u003C/li>\n\u003Cli>New properties will be a rdfs:subPropertyOf of \u003Ccode>d3f:d3fend-object-property\u003C/code>\u003C/li>\n\u003Cli>New classes will be a subtype of their archetypal box unless there is one or more \u003Ccode>rdfs:subClassOf\u003C/code> assertions on that &quot;Node&quot;. New classes with no archetype will be a \u003Ccode>D3FENDThing\u003C/code>\u003C/li>\n\u003Cli>If a new class is indicated via the \u003Ccode>:\u003C/code> , all Edges on that Node are assumed to be owl:someValuesFrom restrictions against the target class.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ol>\n"],"uses":{"params":["doc"]}}]}
