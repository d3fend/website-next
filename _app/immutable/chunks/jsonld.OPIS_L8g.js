import{c as mt,g as hr}from"./_commonjsHelpers.BosuxZz1.js";import{r as pr}from"./index.HGyOB-Dh.js";function gr(e,t){for(var n=0;n<t.length;n++){const r=t[n];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in e)){const a=Object.getOwnPropertyDescriptor(r,i);a&&Object.defineProperty(e,i,a.get?a:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}))}var Fn={},Yt=class Hn{constructor(t,n=new Map,r=0){this.prefix=t,this._existing=n,this.counter=r}clone(){const{prefix:t,_existing:n,counter:r}=this;return new Hn(t,new Map(n),r)}getId(t){const n=t&&this._existing.get(t);if(n)return n;const r=this.prefix+this.counter;return this.counter++,t&&this._existing.set(t,r),r}hasId(t){return this._existing.has(t)}getOldIds(){return[...this._existing.keys()]}};(function(e,t){if(e.setImmediate)return;var n=1,r={},i=!1,a=e.document,s;function o(v){typeof v!="function"&&(v=new Function(""+v));for(var I=new Array(arguments.length-1),b=0;b<I.length;b++)I[b]=arguments[b+1];var x={callback:v,args:I};return r[n]=x,s(n),n++}function c(v){delete r[v]}function d(v){var I=v.callback,b=v.args;switch(b.length){case 0:I();break;case 1:I(b[0]);break;case 2:I(b[0],b[1]);break;case 3:I(b[0],b[1],b[2]);break;default:I.apply(t,b);break}}function p(v){if(i)setTimeout(p,0,v);else{var I=r[v];if(I){i=!0;try{d(I)}finally{c(v),i=!1}}}}function h(){s=function(v){process.nextTick(function(){p(v)})}}function f(){if(e.postMessage&&!e.importScripts){var v=!0,I=e.onmessage;return e.onmessage=function(){v=!1},e.postMessage("","*"),e.onmessage=I,v}}function l(){var v="setImmediate$"+Math.random()+"$",I=function(b){b.source===e&&typeof b.data=="string"&&b.data.indexOf(v)===0&&p(+b.data.slice(v.length))};e.addEventListener?e.addEventListener("message",I,!1):e.attachEvent("onmessage",I),s=function(b){e.postMessage(v+b,"*")}}function u(){var v=new MessageChannel;v.port1.onmessage=function(I){var b=I.data;p(b)},s=function(I){v.port2.postMessage(I)}}function y(){var v=a.documentElement;s=function(I){var b=a.createElement("script");b.onreadystatechange=function(){p(I),b.onreadystatechange=null,v.removeChild(b),b=null},v.appendChild(b)}}function g(){s=function(v){setTimeout(p,0,v)}}var m=Object.getPrototypeOf&&Object.getPrototypeOf(e);m=m&&m.setTimeout?m:e,{}.toString.call(e.process)==="[object process]"?h():f()?l():e.MessageChannel?u():a&&"onreadystatechange"in a.createElement("script")?y():g(),m.setImmediate=o,m.clearImmediate=c})(typeof self>"u"?typeof mt>"u"?mt:mt:self);/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const vt=self.crypto||self.msCrypto;var pt=class{constructor(t){if(!(vt&&vt.subtle))throw new Error("crypto.subtle not found.");if(t==="sha256")this.algorithm={name:"SHA-256"};else if(t==="sha1")this.algorithm={name:"SHA-1"};else throw new Error(`Unsupported algorithm "${t}".`);this._content=""}update(t){this._content+=t}async digest(){const t=new TextEncoder().encode(this._content),n=new Uint8Array(await vt.subtle.digest(this.algorithm,t));let r="";for(let i=0;i<n.length;++i)r+=n[i].toString(16).padStart(2,"0");return r}};/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */var Pn=class{constructor(t){this.current=t.sort(),this.done=!1,this.dir=new Map;for(let n=0;n<t.length;++n)this.dir.set(t[n],!0)}hasNext(){return!this.done}next(){const{current:t,dir:n}=this,r=t.slice();let i=null,a=0;const s=t.length;for(let o=0;o<s;++o){const c=t[o],d=n.get(c);(i===null||c>i)&&(d&&o>0&&c>t[o-1]||!d&&o<s-1&&c>t[o+1])&&(i=c,a=o)}if(i===null)this.done=!0;else{const o=n.get(i)?a-1:a+1;t[a]=t[o],t[o]=i;for(const c of t)c>i&&n.set(c,!n.get(c))}return r}};/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const yr="http://www.w3.org/1999/02/22-rdf-syntax-ns#",bt=yr+"langString",wt="http://www.w3.org/2001/XMLSchema#string",te="NamedNode",Ie="BlankNode",rt="Literal",an="DefaultGraph",Me={};(()=>{const e="(?:<([^:]+:[^>]*)>)",n="A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�"+"_",r=n+"0-9-·̀-ͯ‿-⁀",a="(_:(?:["+n+"0-9])(?:(?:["+r+".])*(?:["+r+"]))?)",s='"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"',o="(?:\\^\\^"+e+")",d="(?:"+s+"(?:"+o+"|"+"(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))"+")?)",p="[ \\t]+",h="[ \\t]*",f="(?:"+e+"|"+a+")"+p,l=e+p,u="(?:"+e+"|"+a+"|"+d+")"+h,y="(?:\\.|(?:(?:"+e+"|"+a+")"+h+"\\.))";Me.eoln=/(?:\r\n)|(?:\n)|(?:\r)/g,Me.empty=new RegExp("^"+h+"$"),Me.quad=new RegExp("^"+h+f+l+u+y+h+"$")})();var Zt=class st{static parse(t){const n=[],r={},i=t.split(Me.eoln);let a=0;for(const s of i){if(a++,Me.empty.test(s))continue;const o=s.match(Me.quad);if(o===null)throw new Error("N-Quads parse error on line "+a+".");const c={subject:null,predicate:null,object:null,graph:null};if(o[1]!==void 0?c.subject={termType:te,value:o[1]}:c.subject={termType:Ie,value:o[2]},c.predicate={termType:te,value:o[3]},o[4]!==void 0?c.object={termType:te,value:o[4]}:o[5]!==void 0?c.object={termType:Ie,value:o[5]}:(c.object={termType:rt,value:void 0,datatype:{termType:te}},o[7]!==void 0?c.object.datatype.value=o[7]:o[8]!==void 0?(c.object.datatype.value=bt,c.object.language=o[8]):c.object.datatype.value=wt,c.object.value=Ir(o[6])),o[9]!==void 0?c.graph={termType:te,value:o[9]}:o[10]!==void 0?c.graph={termType:Ie,value:o[10]}:c.graph={termType:an,value:""},!(c.graph.value in r))r[c.graph.value]=[c],n.push(c);else{let d=!0;const p=r[c.graph.value];for(const h of p)if(mr(h,c)){d=!1;break}d&&(p.push(c),n.push(c))}}return n}static serialize(t){Array.isArray(t)||(t=st.legacyDatasetToQuads(t));const n=[];for(const r of t)n.push(st.serializeQuad(r));return n.sort().join("")}static serializeQuadComponents(t,n,r,i){let a="";return t.termType===te?a+=`<${t.value}>`:a+=`${t.value}`,a+=` <${n.value}> `,r.termType===te?a+=`<${r.value}>`:r.termType===Ie?a+=r.value:(a+=`"${br(r.value)}"`,r.datatype.value===bt?r.language&&(a+=`@${r.language}`):r.datatype.value!==wt&&(a+=`^^<${r.datatype.value}>`)),i.termType===te?a+=` <${i.value}>`:i.termType===Ie&&(a+=` ${i.value}`),a+=` .
`,a}static serializeQuad(t){return st.serializeQuadComponents(t.subject,t.predicate,t.object,t.graph)}static legacyDatasetToQuads(t){const n=[],r={"blank node":Ie,IRI:te,literal:rt};for(const i in t)t[i].forEach(s=>{const o={};for(const c in s){const d=s[c],p={termType:r[d.type],value:d.value};p.termType===rt&&(p.datatype={termType:te},"datatype"in d&&(p.datatype.value=d.datatype),"language"in d?("datatype"in d||(p.datatype.value=bt),p.language=d.language):"datatype"in d||(p.datatype.value=wt)),o[c]=p}i==="@default"?o.graph={termType:an,value:""}:o.graph={termType:i.startsWith("_:")?Ie:te,value:i},n.push(o)});return n}};function mr(e,t){return!(e.subject.termType===t.subject.termType&&e.object.termType===t.object.termType)||!(e.subject.value===t.subject.value&&e.predicate.value===t.predicate.value&&e.object.value===t.object.value)?!1:e.object.termType!==rt?!0:e.object.datatype.termType===t.object.datatype.termType&&e.object.language===t.object.language&&e.object.datatype.value===t.object.datatype.value}const vr=/["\\\n\r]/g;function br(e){return e.replace(vr,function(t){switch(t){case'"':return'\\"';case"\\":return"\\\\";case`
`:return"\\n";case"\r":return"\\r"}})}const wr=/(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;function Ir(e){return e.replace(wr,function(t,n,r,i){if(n)switch(n){case"t":return"	";case"b":return"\b";case"n":return`
`;case"r":return"\r";case"f":return"\f";case'"':return'"';case"'":return"'";case"\\":return"\\"}if(r)return String.fromCharCode(parseInt(r,16));if(i)throw new Error("Unsupported U escape")})}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const on=Yt,xr=pt,Er=Pn,ln=Zt;var Bn=class{constructor({createMessageDigest:t=()=>new xr("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:r=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new on("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=r,this.quads=null,this.deepIterations=null}async main(t){this.deepIterations=new Map,this.quads=t;for(const c of t)this._addBlankNodeQuadInfo({quad:c,component:c.subject}),this._addBlankNodeQuadInfo({quad:c,component:c.object}),this._addBlankNodeQuadInfo({quad:c,component:c.graph});const n=new Map,r=[...this.blankNodeInfo.keys()];let i=0;for(const c of r)++i%100===0&&await this._yield(),await this._hashAndTrackBlankNode({id:c,hashToBlankNodes:n});const a=[...n.keys()].sort(),s=[];for(const c of a){const d=n.get(c);if(d.length>1){s.push(d);continue}const p=d[0];this.canonicalIssuer.getId(p)}for(const c of s){const d=[];for(const p of c){if(this.canonicalIssuer.hasId(p))continue;const h=new on("_:b");h.getId(p);const f=await this.hashNDegreeQuads(p,h);d.push(f)}d.sort(Nr);for(const p of d){const h=p.issuer.getOldIds();for(const f of h)this.canonicalIssuer.getId(f)}}const o=[];for(const c of this.quads){const d=ln.serializeQuadComponents(this._componentWithCanonicalId(c.subject),c.predicate,this._componentWithCanonicalId(c.object),this._componentWithCanonicalId(c.graph));o.push(d)}return o.sort(),o.join("")}async hashFirstDegreeQuads(t){const n=[],r=this.blankNodeInfo.get(t),i=r.quads;for(const s of i){const o={subject:null,predicate:s.predicate,object:null,graph:null};o.subject=this.modifyFirstDegreeComponent(t,s.subject,"subject"),o.object=this.modifyFirstDegreeComponent(t,s.object,"object"),o.graph=this.modifyFirstDegreeComponent(t,s.graph,"graph"),n.push(ln.serializeQuad(o))}n.sort();const a=this.createMessageDigest();for(const s of n)a.update(s);return r.hash=await a.digest(),r.hash}async hashRelatedBlankNode(t,n,r,i){let a;this.canonicalIssuer.hasId(t)?a=this.canonicalIssuer.getId(t):r.hasId(t)?a=r.getId(t):a=this.blankNodeInfo.get(t).hash;const s=this.createMessageDigest();return s.update(i),i!=="g"&&s.update(this.getRelatedPredicate(n)),s.update(a),s.digest()}async hashNDegreeQuads(t,n){const r=this.deepIterations.get(t)||0;if(r>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,r+1);const i=this.createMessageDigest(),a=await this.createHashToRelated(t,n),s=[...a.keys()].sort();for(const o of s){i.update(o);let c="",d;const p=new Er(a.get(o));let h=0;for(;p.hasNext();){const f=p.next();++h%3===0&&await this._yield();let l=n.clone(),u="";const y=[];let g=!1;for(const m of f)if(this.canonicalIssuer.hasId(m)?u+=this.canonicalIssuer.getId(m):(l.hasId(m)||y.push(m),u+=l.getId(m)),c.length!==0&&u>c){g=!0;break}if(!g){for(const m of y){const v=await this.hashNDegreeQuads(m,l);if(u+=l.getId(m),u+=`<${v.hash}>`,l=v.issuer,c.length!==0&&u>c){g=!0;break}}g||(c.length===0||u<c)&&(c=u,d=l)}}i.update(c),n=d}return{hash:await i.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}async createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;let a=0;for(const s of i)++a%100===0&&await this._yield(),await Promise.all([this._addRelatedBlankNodeHash({quad:s,component:s.subject,position:"s",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:s,component:s.object,position:"o",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:s,component:s.graph,position:"g",id:t,issuer:n,hashToRelated:r})]);return r}async _hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const r=await this.hashFirstDegreeQuads(t),i=n.get(r);i?i.push(t):n.set(r,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const r=n.value,i=this.blankNodeInfo.get(r);i?i.quads.add(t):this.blankNodeInfo.set(r,{quads:new Set([t]),hash:null})}async _addRelatedBlankNodeHash({quad:t,component:n,position:r,id:i,issuer:a,hashToRelated:s}){if(!(n.termType==="BlankNode"&&n.value!==i))return;const o=n.value,c=await this.hashRelatedBlankNode(o,t,a,r),d=s.get(c);d?d.push(o):s.set(c,[o])}_componentWithCanonicalId(t){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}async _yield(){return new Promise(t=>setImmediate(t))}};function Nr(e,t){return e.hash<t.hash?-1:e.hash>t.hash?1:0}/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const _r=pt,jr=Bn;var Sr=class extends jr{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new _r("sha1")}modifyFirstDegreeComponent(t,n,r){return n.termType!=="BlankNode"?n:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return t.predicate.value}async createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;let a=0;for(const s of i){let o,c;if(s.subject.termType==="BlankNode"&&s.subject.value!==t)c=s.subject.value,o="p";else if(s.object.termType==="BlankNode"&&s.object.value!==t)c=s.object.value,o="r";else continue;++a%100===0&&await this._yield();const d=await this.hashRelatedBlankNode(c,s,n,o),p=r.get(d);p?p.push(c):r.set(d,[c])}return r}};/*!
 * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.
 */const cn=Yt,Dr=pt,Or=Pn,dn=Zt;var Un=class{constructor({createMessageDigest:t=()=>new Dr("sha256"),canonicalIdMap:n=new Map,maxDeepIterations:r=1/0}={}){this.name="URDNA2015",this.blankNodeInfo=new Map,this.canonicalIssuer=new cn("_:c14n",n),this.createMessageDigest=t,this.maxDeepIterations=r,this.quads=null,this.deepIterations=null}main(t){this.deepIterations=new Map,this.quads=t;for(const o of t)this._addBlankNodeQuadInfo({quad:o,component:o.subject}),this._addBlankNodeQuadInfo({quad:o,component:o.object}),this._addBlankNodeQuadInfo({quad:o,component:o.graph});const n=new Map,r=[...this.blankNodeInfo.keys()];for(const o of r)this._hashAndTrackBlankNode({id:o,hashToBlankNodes:n});const i=[...n.keys()].sort(),a=[];for(const o of i){const c=n.get(o);if(c.length>1){a.push(c);continue}const d=c[0];this.canonicalIssuer.getId(d)}for(const o of a){const c=[];for(const d of o){if(this.canonicalIssuer.hasId(d))continue;const p=new cn("_:b");p.getId(d);const h=this.hashNDegreeQuads(d,p);c.push(h)}c.sort(Rr);for(const d of c){const p=d.issuer.getOldIds();for(const h of p)this.canonicalIssuer.getId(h)}}const s=[];for(const o of this.quads){const c=dn.serializeQuadComponents(this._componentWithCanonicalId({component:o.subject}),o.predicate,this._componentWithCanonicalId({component:o.object}),this._componentWithCanonicalId({component:o.graph}));s.push(c)}return s.sort(),s.join("")}hashFirstDegreeQuads(t){const n=[],r=this.blankNodeInfo.get(t),i=r.quads;for(const s of i){const o={subject:null,predicate:s.predicate,object:null,graph:null};o.subject=this.modifyFirstDegreeComponent(t,s.subject,"subject"),o.object=this.modifyFirstDegreeComponent(t,s.object,"object"),o.graph=this.modifyFirstDegreeComponent(t,s.graph,"graph"),n.push(dn.serializeQuad(o))}n.sort();const a=this.createMessageDigest();for(const s of n)a.update(s);return r.hash=a.digest(),r.hash}hashRelatedBlankNode(t,n,r,i){let a;this.canonicalIssuer.hasId(t)?a=this.canonicalIssuer.getId(t):r.hasId(t)?a=r.getId(t):a=this.blankNodeInfo.get(t).hash;const s=this.createMessageDigest();return s.update(i),i!=="g"&&s.update(this.getRelatedPredicate(n)),s.update(a),s.digest()}hashNDegreeQuads(t,n){const r=this.deepIterations.get(t)||0;if(r>this.maxDeepIterations)throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);this.deepIterations.set(t,r+1);const i=this.createMessageDigest(),a=this.createHashToRelated(t,n),s=[...a.keys()].sort();for(const o of s){i.update(o);let c="",d;const p=new Or(a.get(o));for(;p.hasNext();){const h=p.next();let f=n.clone(),l="";const u=[];let y=!1;for(const g of h)if(this.canonicalIssuer.hasId(g)?l+=this.canonicalIssuer.getId(g):(f.hasId(g)||u.push(g),l+=f.getId(g)),c.length!==0&&l>c){y=!0;break}if(!y){for(const g of u){const m=this.hashNDegreeQuads(g,f);if(l+=f.getId(g),l+=`<${m.hash}>`,f=m.issuer,c.length!==0&&l>c){y=!0;break}}y||(c.length===0||l<c)&&(c=l,d=f)}}i.update(c),n=d}return{hash:i.digest(),issuer:n}}modifyFirstDegreeComponent(t,n){return n.termType!=="BlankNode"?n:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return`<${t.predicate.value}>`}createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;for(const a of i)this._addRelatedBlankNodeHash({quad:a,component:a.subject,position:"s",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:a,component:a.object,position:"o",id:t,issuer:n,hashToRelated:r}),this._addRelatedBlankNodeHash({quad:a,component:a.graph,position:"g",id:t,issuer:n,hashToRelated:r});return r}_hashAndTrackBlankNode({id:t,hashToBlankNodes:n}){const r=this.hashFirstDegreeQuads(t),i=n.get(r);i?i.push(t):n.set(r,[t])}_addBlankNodeQuadInfo({quad:t,component:n}){if(n.termType!=="BlankNode")return;const r=n.value,i=this.blankNodeInfo.get(r);i?i.quads.add(t):this.blankNodeInfo.set(r,{quads:new Set([t]),hash:null})}_addRelatedBlankNodeHash({quad:t,component:n,position:r,id:i,issuer:a,hashToRelated:s}){if(!(n.termType==="BlankNode"&&n.value!==i))return;const o=n.value,c=this.hashRelatedBlankNode(o,t,a,r),d=s.get(c);d?d.push(o):s.set(c,[o])}_componentWithCanonicalId({component:t}){return t.termType==="BlankNode"&&!t.value.startsWith(this.canonicalIssuer.prefix)?{termType:"BlankNode",value:this.canonicalIssuer.getId(t.value)}:t}};function Rr(e,t){return e.hash<t.hash?-1:e.hash>t.hash?1:0}/*!
 * Copyright (c) 2016-2021 Digital Bazaar, Inc. All rights reserved.
 */const Lr=pt,Ar=Un;var Tr=class extends Ar{constructor(){super(),this.name="URGNA2012",this.createMessageDigest=()=>new Lr("sha1")}modifyFirstDegreeComponent(t,n,r){return n.termType!=="BlankNode"?n:r==="graph"?{termType:"BlankNode",value:"_:g"}:{termType:"BlankNode",value:n.value===t?"_:a":"_:z"}}getRelatedPredicate(t){return t.predicate.value}createHashToRelated(t,n){const r=new Map,i=this.blankNodeInfo.get(t).quads;for(const a of i){let s,o;if(a.subject.termType==="BlankNode"&&a.subject.value!==t)o=a.subject.value,s="p";else if(a.object.termType==="BlankNode"&&a.object.value!==t)o=a.object.value,s="r";else continue;const c=this.hashRelatedBlankNode(o,a,n,s),d=r.get(c);d?d.push(o):r.set(c,[o])}return r}};(function(e){const t=Bn,n=Sr,r=Un,i=Tr;let a;try{a=pr}catch{}function s(o){return Array.isArray(o)?o:e.NQuads.legacyDatasetToQuads(o)}e.NQuads=Zt,e.IdentifierIssuer=Yt,e._rdfCanonizeNative=function(o){return o&&(a=o),a},e.canonize=async function(o,c){const d=s(o);if(c.useNative){if(!a)throw new Error("rdf-canonize-native not available");if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return new Promise((p,h)=>a.canonize(d,c,(f,l)=>f?h(f):p(l)))}if(c.algorithm==="URDNA2015")return new t(c).main(d);if(c.algorithm==="URGNA2012"){if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new n(c).main(d)}throw"algorithm"in c?new Error("Invalid RDF Dataset Canonicalization algorithm: "+c.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")},e._canonizeSync=function(o,c){const d=s(o);if(c.useNative){if(!a)throw new Error("rdf-canonize-native not available");if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "useNative".');return a.canonizeSync(d,c)}if(c.algorithm==="URDNA2015")return new r(c).main(d);if(c.algorithm==="URGNA2012"){if(c.createMessageDigest)throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');return new i(c).main(d)}throw"algorithm"in c?new Error("Invalid RDF Dataset Canonicalization algorithm: "+c.algorithm):new Error("No RDF Dataset Canonicalization algorithm specified.")}})(Fn);var Ct=Fn;const Z={};var z=Z;Z.isArray=Array.isArray;Z.isBoolean=e=>typeof e=="boolean"||Object.prototype.toString.call(e)==="[object Boolean]";Z.isDouble=e=>Z.isNumber(e)&&(String(e).indexOf(".")!==-1||Math.abs(e)>=1e21);Z.isEmptyObject=e=>Z.isObject(e)&&Object.keys(e).length===0;Z.isNumber=e=>typeof e=="number"||Object.prototype.toString.call(e)==="[object Number]";Z.isNumeric=e=>!isNaN(parseFloat(e))&&isFinite(e);Z.isObject=e=>Object.prototype.toString.call(e)==="[object Object]";Z.isString=e=>typeof e=="string"||Object.prototype.toString.call(e)==="[object String]";Z.isUndefined=e=>typeof e>"u";const De=z,he={};var pe=he;he.isSubject=e=>De.isObject(e)&&!("@value"in e||"@set"in e||"@list"in e)?Object.keys(e).length>1||!("@id"in e):!1;he.isSubjectReference=e=>De.isObject(e)&&Object.keys(e).length===1&&"@id"in e;he.isValue=e=>De.isObject(e)&&"@value"in e;he.isList=e=>De.isObject(e)&&"@list"in e;he.isGraph=e=>De.isObject(e)&&"@graph"in e&&Object.keys(e).filter(t=>t!=="@id"&&t!=="@index").length===1;he.isSimpleGraph=e=>he.isGraph(e)&&!("@id"in e);he.isBlankNode=e=>{if(De.isObject(e)){if("@id"in e){const t=e["@id"];return!De.isString(t)||t.indexOf("_:")===0}return Object.keys(e).length===0||!("@value"in e||"@set"in e||"@list"in e)}return!1};var C=class extends Error{constructor(t="An unspecified JSON-LD error occurred.",n="jsonld.Error",r={}){super(t),this.name=n,this.message=t,this.details=r}};const Ke=pe,J=z,qn=Ct.IdentifierIssuer,kr=C,Mr=/^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/,$r=/(?:<[^>]*?>|"[^"]*?"|[^,])+/g,Jr=/\s*<([^>]*?)>\s*(?:;\s*(.*))?/,Fr=/(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g,Hr=/^@[a-zA-Z]+$/,un={headers:{accept:"application/ld+json, application/json"}},j={};var ee=j;j.IdentifierIssuer=qn;j.REGEX_BCP47=Mr;j.REGEX_KEYWORD=Hr;j.clone=function(e){if(e&&typeof e=="object"){let t;if(J.isArray(e)){t=[];for(let n=0;n<e.length;++n)t[n]=j.clone(e[n])}else if(e instanceof Map){t=new Map;for(const[n,r]of e)t.set(n,j.clone(r))}else if(e instanceof Set){t=new Set;for(const n of e)t.add(j.clone(n))}else if(J.isObject(e)){t={};for(const n in e)t[n]=j.clone(e[n])}else t=e.toString();return t}return e};j.asArray=function(e){return Array.isArray(e)?e:[e]};j.buildHeaders=(e={})=>{if(Object.keys(e).some(n=>n.toLowerCase()==="accept"))throw new RangeError('Accept header may not be specified; only "'+un.headers.accept+'" is supported.');return Object.assign({Accept:un.headers.accept},e)};j.parseLinkHeader=e=>{const t={},n=e.match($r);for(let r=0;r<n.length;++r){let i=n[r].match(Jr);if(!i)continue;const a={target:i[1]},s=i[2];for(;i=Fr.exec(s);)a[i[1]]=i[2]===void 0?i[3]:i[2];const o=a.rel||"";Array.isArray(t[o])?t[o].push(a):t.hasOwnProperty(o)?t[o]=[t[o],a]:t[o]=a}return t};j.validateTypeValue=(e,t)=>{if(!J.isString(e)&&!(J.isArray(e)&&e.every(n=>J.isString(n)))){if(t&&J.isObject(e))switch(Object.keys(e).length){case 0:return;case 1:if("@default"in e&&j.asArray(e["@default"]).every(n=>J.isString(n)))return}throw new kr('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{code:"invalid type value",value:e})}};j.hasProperty=(e,t)=>{if(e.hasOwnProperty(t)){const n=e[t];return!J.isArray(n)||n.length>0}return!1};j.hasValue=(e,t,n)=>{if(j.hasProperty(e,t)){let r=e[t];const i=Ke.isList(r);if(J.isArray(r)||i){i&&(r=r["@list"]);for(let a=0;a<r.length;++a)if(j.compareValues(n,r[a]))return!0}else if(!J.isArray(n))return j.compareValues(n,r)}return!1};j.addValue=(e,t,n,r)=>{if(r=r||{},"propertyIsArray"in r||(r.propertyIsArray=!1),"valueIsArray"in r||(r.valueIsArray=!1),"allowDuplicate"in r||(r.allowDuplicate=!0),"prependValue"in r||(r.prependValue=!1),r.valueIsArray)e[t]=n;else if(J.isArray(n)){n.length===0&&r.propertyIsArray&&!e.hasOwnProperty(t)&&(e[t]=[]),r.prependValue&&(n=n.concat(e[t]),e[t]=[]);for(let i=0;i<n.length;++i)j.addValue(e,t,n[i],r)}else if(e.hasOwnProperty(t)){const i=!r.allowDuplicate&&j.hasValue(e,t,n);!J.isArray(e[t])&&(!i||r.propertyIsArray)&&(e[t]=[e[t]]),i||(r.prependValue?e[t].unshift(n):e[t].push(n))}else e[t]=r.propertyIsArray?[n]:n};j.getValues=(e,t)=>[].concat(e[t]||[]);j.removeProperty=(e,t)=>{delete e[t]};j.removeValue=(e,t,n,r)=>{r=r||{},"propertyIsArray"in r||(r.propertyIsArray=!1);const i=j.getValues(e,t).filter(a=>!j.compareValues(a,n));i.length===0?j.removeProperty(e,t):i.length===1&&!r.propertyIsArray?e[t]=i[0]:e[t]=i};j.relabelBlankNodes=(e,t)=>{t=t||{};const n=t.issuer||new qn("_:b");return it(n,e)};j.compareValues=(e,t)=>e===t||Ke.isValue(e)&&Ke.isValue(t)&&e["@value"]===t["@value"]&&e["@type"]===t["@type"]&&e["@language"]===t["@language"]&&e["@index"]===t["@index"]?!0:J.isObject(e)&&"@id"in e&&J.isObject(t)&&"@id"in t?e["@id"]===t["@id"]:!1;j.compareShortestLeast=(e,t)=>e.length<t.length?-1:t.length<e.length?1:e===t?0:e<t?-1:1;function it(e,t){if(J.isArray(t))for(let n=0;n<t.length;++n)t[n]=it(e,t[n]);else if(Ke.isList(t))t["@list"]=it(e,t["@list"]);else if(J.isObject(t)){Ke.isBlankNode(t)&&(t["@id"]=e.getId(t["@id"]));const n=Object.keys(t).sort();for(let r=0;r<n.length;++r){const i=n[r];i!=="@id"&&(t[i]=it(e,t[i]))}}return t}const ne="http://www.w3.org/1999/02/22-rdf-syntax-ns#",Fe="http://www.w3.org/2001/XMLSchema#";var en={LINK_HEADER_REL:"http://www.w3.org/ns/json-ld#context",LINK_HEADER_CONTEXT:"http://www.w3.org/ns/json-ld#context",RDF:ne,RDF_LIST:ne+"List",RDF_FIRST:ne+"first",RDF_REST:ne+"rest",RDF_NIL:ne+"nil",RDF_TYPE:ne+"type",RDF_PLAIN_LITERAL:ne+"PlainLiteral",RDF_XML_LITERAL:ne+"XMLLiteral",RDF_JSON_LITERAL:ne+"JSON",RDF_OBJECT:ne+"object",RDF_LANGSTRING:ne+"langString",XSD:Fe,XSD_BOOLEAN:Fe+"boolean",XSD_DOUBLE:Fe+"double",XSD_INTEGER:Fe+"integer",XSD_STRING:Fe+"string"},It,fn;function Vn(){return fn||(fn=1,It=class{constructor(){this._requests={}}wrapLoader(t){const n=this;return n._loader=t,function(){return n.add.apply(n,arguments)}}async add(t){let n=this._requests[t];if(n)return Promise.resolve(n);n=this._requests[t]=this._loader(t);try{return await n}finally{delete this._requests[t]}}}),It}const gt=z,F={};var we=F;F.parsers={simple:{keys:["href","scheme","authority","path","query","fragment"],regex:/^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/},full:{keys:["href","protocol","scheme","authority","auth","user","password","hostname","port","path","directory","file","query","fragment"],regex:/^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/}};F.parse=(e,t)=>{const n={},r=F.parsers[t||"full"],i=r.regex.exec(e);let a=r.keys.length;for(;a--;)n[r.keys[a]]=i[a]===void 0?null:i[a];return(n.scheme==="https"&&n.port==="443"||n.scheme==="http"&&n.port==="80")&&(n.href=n.href.replace(":"+n.port,""),n.authority=n.authority.replace(":"+n.port,""),n.port=null),n.normalizedPath=F.removeDotSegments(n.path),n};F.prependBase=(e,t)=>{if(e===null||F.isAbsolute(t))return t;(!e||gt.isString(e))&&(e=F.parse(e||""));const n=F.parse(t),r={protocol:e.protocol||""};if(n.authority!==null)r.authority=n.authority,r.path=n.path,r.query=n.query;else if(r.authority=e.authority,n.path==="")r.path=e.path,n.query!==null?r.query=n.query:r.query=e.query;else{if(n.path.indexOf("/")===0)r.path=n.path;else{let a=e.path;a=a.substr(0,a.lastIndexOf("/")+1),(a.length>0||e.authority)&&a.substr(-1)!=="/"&&(a+="/"),a+=n.path,r.path=a}r.query=n.query}n.path!==""&&(r.path=F.removeDotSegments(r.path));let i=r.protocol;return r.authority!==null&&(i+="//"+r.authority),i+=r.path,r.query!==null&&(i+="?"+r.query),n.fragment!==null&&(i+="#"+n.fragment),i===""&&(i="./"),i};F.removeBase=(e,t)=>{if(e===null)return t;(!e||gt.isString(e))&&(e=F.parse(e||""));let n="";if(e.href!==""?n+=(e.protocol||"")+"//"+(e.authority||""):t.indexOf("//")&&(n+="//"),t.indexOf(n)!==0)return t;const r=F.parse(t.substr(n.length)),i=e.normalizedPath.split("/"),a=r.normalizedPath.split("/"),s=r.fragment||r.query?0:1;for(;i.length>0&&a.length>s&&i[0]===a[0];)i.shift(),a.shift();let o="";if(i.length>0){i.pop();for(let c=0;c<i.length;++c)o+="../"}return o+=a.join("/"),r.query!==null&&(o+="?"+r.query),r.fragment!==null&&(o+="#"+r.fragment),o===""&&(o="./"),o};F.removeDotSegments=e=>{if(e.length===0)return"";const t=e.split("/"),n=[];for(;t.length>0;){const r=t.shift(),i=t.length===0;if(r==="."){i&&n.push("");continue}if(r===".."){n.pop(),i&&n.push("");continue}n.push(r)}return e[0]==="/"&&n.length>0&&n[0]!==""&&n.unshift(""),n.length===1&&n[0]===""?"/":n.join("/")};const Pr=/^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;F.isAbsolute=e=>gt.isString(e)&&Pr.test(e);F.isRelative=e=>gt.isString(e);const{parseLinkHeader:Br,buildHeaders:Ur}=ee,{LINK_HEADER_CONTEXT:qr}=en,He=C,Vr=Vn(),{prependBase:Gr}=we,zr=/(^|(\r\n))link:/i;var Xr=({secure:e,headers:t={},xhr:n}={headers:{}})=>{return t=Ur(t),new Vr().wrapLoader(i);async function i(a){if(a.indexOf("http:")!==0&&a.indexOf("https:")!==0)throw new He('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{code:"loading document failed",url:a});if(e&&a.indexOf("https")!==0)throw new He(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{code:"loading document failed",url:a});let s;try{s=await Qr(n,a,t)}catch(h){throw new He("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{code:"loading document failed",url:a,cause:h})}if(s.status>=400)throw new He("URL could not be dereferenced: "+s.statusText,"jsonld.LoadDocumentError",{code:"loading document failed",url:a,httpStatusCode:s.status});let o={contextUrl:null,documentUrl:a,document:s.response},c=null;const d=s.getResponseHeader("Content-Type");let p;if(zr.test(s.getAllResponseHeaders())&&(p=s.getResponseHeader("Link")),p&&d!=="application/ld+json"){const h=Br(p),f=h[qr];if(Array.isArray(f))throw new He("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{code:"multiple context link headers",url:a});f&&(o.contextUrl=f.target),c=h.alternate,c&&c.type=="application/ld+json"&&!(d||"").match(/^application\/(\w*\+)?json$/)&&(o=await i(Gr(a,c.target)))}return o}};function Qr(e,t,n){e=e||XMLHttpRequest;const r=new e;return new Promise((i,a)=>{r.onload=()=>i(r),r.onerror=s=>a(s),r.open("GET",t,!0);for(const s in n)r.setRequestHeader(s,n[s]);r.send()})}const Kr=Xr,tn={};var Wr=tn;tn.setupDocumentLoaders=function(e){typeof XMLHttpRequest<"u"&&(e.documentLoaders.xhr=Kr,e.useDocumentLoader("xhr"))};tn.setupGlobals=function(e){typeof globalThis.JsonLdProcessor>"u"&&Object.defineProperty(globalThis,"JsonLdProcessor",{writable:!0,enumerable:!1,configurable:!0,value:e.JsonLdProcessor})};var xt,hn;function Yr(){return hn||(hn=1,xt=function(e){e.prototype[Symbol.iterator]=function*(){for(let t=this.head;t;t=t.next)yield t.value}}),xt}var Zr=_;_.Node=Oe;_.create=_;function _(e){var t=this;if(t instanceof _||(t=new _),t.tail=null,t.head=null,t.length=0,e&&typeof e.forEach=="function")e.forEach(function(i){t.push(i)});else if(arguments.length>0)for(var n=0,r=arguments.length;n<r;n++)t.push(arguments[n]);return t}_.prototype.removeNode=function(e){if(e.list!==this)throw new Error("removing node which does not belong to this list");var t=e.next,n=e.prev;return t&&(t.prev=n),n&&(n.next=t),e===this.head&&(this.head=t),e===this.tail&&(this.tail=n),e.list.length--,e.next=null,e.prev=null,e.list=null,t};_.prototype.unshiftNode=function(e){if(e!==this.head){e.list&&e.list.removeNode(e);var t=this.head;e.list=this,e.next=t,t&&(t.prev=e),this.head=e,this.tail||(this.tail=e),this.length++}};_.prototype.pushNode=function(e){if(e!==this.tail){e.list&&e.list.removeNode(e);var t=this.tail;e.list=this,e.prev=t,t&&(t.next=e),this.tail=e,this.head||(this.head=e),this.length++}};_.prototype.push=function(){for(var e=0,t=arguments.length;e<t;e++)es(this,arguments[e]);return this.length};_.prototype.unshift=function(){for(var e=0,t=arguments.length;e<t;e++)ts(this,arguments[e]);return this.length};_.prototype.pop=function(){if(this.tail){var e=this.tail.value;return this.tail=this.tail.prev,this.tail?this.tail.next=null:this.head=null,this.length--,e}};_.prototype.shift=function(){if(this.head){var e=this.head.value;return this.head=this.head.next,this.head?this.head.prev=null:this.tail=null,this.length--,e}};_.prototype.forEach=function(e,t){t=t||this;for(var n=this.head,r=0;n!==null;r++)e.call(t,n.value,r,this),n=n.next};_.prototype.forEachReverse=function(e,t){t=t||this;for(var n=this.tail,r=this.length-1;n!==null;r--)e.call(t,n.value,r,this),n=n.prev};_.prototype.get=function(e){for(var t=0,n=this.head;n!==null&&t<e;t++)n=n.next;if(t===e&&n!==null)return n.value};_.prototype.getReverse=function(e){for(var t=0,n=this.tail;n!==null&&t<e;t++)n=n.prev;if(t===e&&n!==null)return n.value};_.prototype.map=function(e,t){t=t||this;for(var n=new _,r=this.head;r!==null;)n.push(e.call(t,r.value,this)),r=r.next;return n};_.prototype.mapReverse=function(e,t){t=t||this;for(var n=new _,r=this.tail;r!==null;)n.push(e.call(t,r.value,this)),r=r.prev;return n};_.prototype.reduce=function(e,t){var n,r=this.head;if(arguments.length>1)n=t;else if(this.head)r=this.head.next,n=this.head.value;else throw new TypeError("Reduce of empty list with no initial value");for(var i=0;r!==null;i++)n=e(n,r.value,i),r=r.next;return n};_.prototype.reduceReverse=function(e,t){var n,r=this.tail;if(arguments.length>1)n=t;else if(this.tail)r=this.tail.prev,n=this.tail.value;else throw new TypeError("Reduce of empty list with no initial value");for(var i=this.length-1;r!==null;i--)n=e(n,r.value,i),r=r.prev;return n};_.prototype.toArray=function(){for(var e=new Array(this.length),t=0,n=this.head;n!==null;t++)e[t]=n.value,n=n.next;return e};_.prototype.toArrayReverse=function(){for(var e=new Array(this.length),t=0,n=this.tail;n!==null;t++)e[t]=n.value,n=n.prev;return e};_.prototype.slice=function(e,t){t=t||this.length,t<0&&(t+=this.length),e=e||0,e<0&&(e+=this.length);var n=new _;if(t<e||t<0)return n;e<0&&(e=0),t>this.length&&(t=this.length);for(var r=0,i=this.head;i!==null&&r<e;r++)i=i.next;for(;i!==null&&r<t;r++,i=i.next)n.push(i.value);return n};_.prototype.sliceReverse=function(e,t){t=t||this.length,t<0&&(t+=this.length),e=e||0,e<0&&(e+=this.length);var n=new _;if(t<e||t<0)return n;e<0&&(e=0),t>this.length&&(t=this.length);for(var r=this.length,i=this.tail;i!==null&&r>t;r--)i=i.prev;for(;i!==null&&r>e;r--,i=i.prev)n.push(i.value);return n};_.prototype.splice=function(e,t,...n){e>this.length&&(e=this.length-1),e<0&&(e=this.length+e);for(var r=0,i=this.head;i!==null&&r<e;r++)i=i.next;for(var a=[],r=0;i&&r<t;r++)a.push(i.value),i=this.removeNode(i);i===null&&(i=this.tail),i!==this.head&&i!==this.tail&&(i=i.prev);for(var r=0;r<n.length;r++)i=Cr(this,i,n[r]);return a};_.prototype.reverse=function(){for(var e=this.head,t=this.tail,n=e;n!==null;n=n.prev){var r=n.prev;n.prev=n.next,n.next=r}return this.head=t,this.tail=e,this};function Cr(e,t,n){var r=t===e.head?new Oe(n,null,t,e):new Oe(n,t,t.next,e);return r.next===null&&(e.tail=r),r.prev===null&&(e.head=r),e.length++,r}function es(e,t){e.tail=new Oe(t,e.tail,null,e),e.head||(e.head=e.tail),e.length++}function ts(e,t){e.head=new Oe(t,null,e.head,e),e.tail||(e.tail=e.head),e.length++}function Oe(e,t,n,r){if(!(this instanceof Oe))return new Oe(e,t,n,r);this.list=r,this.value=e,t?(t.next=this,this.prev=t):this.prev=null,n?(n.prev=this,this.next=n):this.next=null}try{Yr()(_)}catch{}const ns=Zr,Ne=Symbol("max"),ue=Symbol("length"),Ae=Symbol("lengthCalculator"),Ve=Symbol("allowStale"),_e=Symbol("maxAge"),de=Symbol("dispose"),pn=Symbol("noDisposeOnSet"),k=Symbol("lruList"),se=Symbol("cache"),Gn=Symbol("updateAgeOnGet"),Et=()=>1;class rs{constructor(t){if(typeof t=="number"&&(t={max:t}),t||(t={}),t.max&&(typeof t.max!="number"||t.max<0))throw new TypeError("max must be a non-negative number");this[Ne]=t.max||1/0;const n=t.length||Et;if(this[Ae]=typeof n!="function"?Et:n,this[Ve]=t.stale||!1,t.maxAge&&typeof t.maxAge!="number")throw new TypeError("maxAge must be a number");this[_e]=t.maxAge||0,this[de]=t.dispose,this[pn]=t.noDisposeOnSet||!1,this[Gn]=t.updateAgeOnGet||!1,this.reset()}set max(t){if(typeof t!="number"||t<0)throw new TypeError("max must be a non-negative number");this[Ne]=t||1/0,Pe(this)}get max(){return this[Ne]}set allowStale(t){this[Ve]=!!t}get allowStale(){return this[Ve]}set maxAge(t){if(typeof t!="number")throw new TypeError("maxAge must be a non-negative number");this[_e]=t,Pe(this)}get maxAge(){return this[_e]}set lengthCalculator(t){typeof t!="function"&&(t=Et),t!==this[Ae]&&(this[Ae]=t,this[ue]=0,this[k].forEach(n=>{n.length=this[Ae](n.value,n.key),this[ue]+=n.length})),Pe(this)}get lengthCalculator(){return this[Ae]}get length(){return this[ue]}get itemCount(){return this[k].length}rforEach(t,n){n=n||this;for(let r=this[k].tail;r!==null;){const i=r.prev;gn(this,t,r,n),r=i}}forEach(t,n){n=n||this;for(let r=this[k].head;r!==null;){const i=r.next;gn(this,t,r,n),r=i}}keys(){return this[k].toArray().map(t=>t.key)}values(){return this[k].toArray().map(t=>t.value)}reset(){this[de]&&this[k]&&this[k].length&&this[k].forEach(t=>this[de](t.key,t.value)),this[se]=new Map,this[k]=new ns,this[ue]=0}dump(){return this[k].map(t=>dt(this,t)?!1:{k:t.key,v:t.value,e:t.now+(t.maxAge||0)}).toArray().filter(t=>t)}dumpLru(){return this[k]}set(t,n,r){if(r=r||this[_e],r&&typeof r!="number")throw new TypeError("maxAge must be a number");const i=r?Date.now():0,a=this[Ae](n,t);if(this[se].has(t)){if(a>this[Ne])return $e(this,this[se].get(t)),!1;const c=this[se].get(t).value;return this[de]&&(this[pn]||this[de](t,c.value)),c.now=i,c.maxAge=r,c.value=n,this[ue]+=a-c.length,c.length=a,this.get(t),Pe(this),!0}const s=new ss(t,n,a,i,r);return s.length>this[Ne]?(this[de]&&this[de](t,n),!1):(this[ue]+=s.length,this[k].unshift(s),this[se].set(t,this[k].head),Pe(this),!0)}has(t){if(!this[se].has(t))return!1;const n=this[se].get(t).value;return!dt(this,n)}get(t){return Nt(this,t,!0)}peek(t){return Nt(this,t,!1)}pop(){const t=this[k].tail;return t?($e(this,t),t.value):null}del(t){$e(this,this[se].get(t))}load(t){this.reset();const n=Date.now();for(let r=t.length-1;r>=0;r--){const i=t[r],a=i.e||0;if(a===0)this.set(i.k,i.v);else{const s=a-n;s>0&&this.set(i.k,i.v,s)}}}prune(){this[se].forEach((t,n)=>Nt(this,n,!1))}}const Nt=(e,t,n)=>{const r=e[se].get(t);if(r){const i=r.value;if(dt(e,i)){if($e(e,r),!e[Ve])return}else n&&(e[Gn]&&(r.value.now=Date.now()),e[k].unshiftNode(r));return i.value}},dt=(e,t)=>{if(!t||!t.maxAge&&!e[_e])return!1;const n=Date.now()-t.now;return t.maxAge?n>t.maxAge:e[_e]&&n>e[_e]},Pe=e=>{if(e[ue]>e[Ne])for(let t=e[k].tail;e[ue]>e[Ne]&&t!==null;){const n=t.prev;$e(e,t),t=n}},$e=(e,t)=>{if(t){const n=t.value;e[de]&&e[de](n.key,n.value),e[ue]-=n.length,e[se].delete(n.key),e[k].removeNode(t)}};class ss{constructor(t,n,r,i,a){this.key=t,this.value=n,this.length=r,this.now=i,this.maxAge=a||0}}const gn=(e,t,n,r)=>{let i=n.value;dt(e,i)&&($e(e,n),e[Ve]||(i=void 0)),i&&t.call(r,i.value,i.key,e)};var zn=rs;const is=zn,as=10;var os=class{constructor({document:t}){this.document=t,this.cache=new is({max:as})}getProcessed(t){return this.cache.get(t)}setProcessed(t,n){this.cache.set(t,n)}};const{isArray:Ht,isObject:Ge,isString:ut}=z,{asArray:ls}=ee,{prependBase:Pt}=we,Ue=C,yn=os,mn=10;var cs=class{constructor({sharedCache:t}){this.perOpCache=new Map,this.sharedCache=t}async resolve({activeCtx:t,context:n,documentLoader:r,base:i,cycles:a=new Set}){n&&Ge(n)&&n["@context"]&&(n=n["@context"]),n=ls(n);const s=[];for(const o of n){if(ut(o)){let p=this._get(o);p||(p=await this._resolveRemoteContext({activeCtx:t,url:o,documentLoader:r,base:i,cycles:a})),Ht(p)?s.push(...p):s.push(p);continue}if(o===null){s.push(new yn({document:null}));continue}Ge(o)||ds(n);const c=JSON.stringify(o);let d=this._get(c);d||(d=new yn({document:o}),this._cacheResolvedContext({key:c,resolved:d,tag:"static"})),s.push(d)}return s}_get(t){let n=this.perOpCache.get(t);if(!n){const r=this.sharedCache.get(t);r&&(n=r.get("static"),n&&this.perOpCache.set(t,n))}return n}_cacheResolvedContext({key:t,resolved:n,tag:r}){if(this.perOpCache.set(t,n),r!==void 0){let i=this.sharedCache.get(t);i||(i=new Map,this.sharedCache.set(t,i)),i.set(r,n)}return n}async _resolveRemoteContext({activeCtx:t,url:n,documentLoader:r,base:i,cycles:a}){n=Pt(i,n);const{context:s,remoteDoc:o}=await this._fetchContext({activeCtx:t,url:n,documentLoader:r,cycles:a});i=o.documentUrl||n,Bt({context:s,base:i});const c=await this.resolve({activeCtx:t,context:s,documentLoader:r,base:i,cycles:a});return this._cacheResolvedContext({key:n,resolved:c,tag:o.tag}),c}async _fetchContext({activeCtx:t,url:n,documentLoader:r,cycles:i}){if(i.size>mn)throw new Ue("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{code:t.processingMode==="json-ld-1.0"?"loading remote context failed":"context overflow",max:mn});if(i.has(n))throw new Ue("Cyclical @context URLs detected.","jsonld.ContextUrlError",{code:t.processingMode==="json-ld-1.0"?"recursive context inclusion":"context overflow",url:n});i.add(n);let a,s;try{s=await r(n),a=s.document||null,ut(a)&&(a=JSON.parse(a))}catch(o){throw new Ue("Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.","jsonld.InvalidUrl",{code:"loading remote context failed",url:n,cause:o})}if(!Ge(a))throw new Ue("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.","jsonld.InvalidUrl",{code:"invalid remote context",url:n});return"@context"in a?a={"@context":a["@context"]}:a={"@context":{}},s.contextUrl&&(Ht(a["@context"])||(a["@context"]=[a["@context"]]),a["@context"].push(s.contextUrl)),{context:a,remoteDoc:s}}};function ds(e){throw new Ue("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:e})}function Bt({context:e,base:t}){if(!e)return;const n=e["@context"];if(ut(n)){e["@context"]=Pt(t,n);return}if(Ht(n)){for(let r=0;r<n.length;++r){const i=n[r];if(ut(i)){n[r]=Pt(t,i);continue}Ge(i)&&Bt({context:{"@context":i},base:t})}return}if(Ge(n))for(const r in n)Bt({context:n[r],base:t})}var us=Ct.NQuads;const nn=C,{isArray:fs}=z,{asArray:Xn}=ee,G={};var We=G;G.defaultEventHandler=null;G.setupEventHandler=({options:e={}})=>{const t=[].concat(e.safe?G.safeEventHandler:[],e.eventHandler?Xn(e.eventHandler):[],G.defaultEventHandler?G.defaultEventHandler:[]);return t.length===0?null:t};G.handleEvent=({event:e,options:t})=>{Qn({event:e,handlers:t.eventHandler})};function Qn({event:e,handlers:t}){let n=!0;for(let r=0;n&&r<t.length;++r){n=!1;const i=t[r];if(fs(i))n=Qn({event:e,handlers:i});else if(typeof i=="function")i({event:e,next:()=>{n=!0}});else if(typeof i=="object")e.code in i?i[e.code]({event:e,next:()=>{n=!0}}):n=!0;else throw new nn("Invalid event handler.","jsonld.InvalidEventHandler",{event:e})}return n}const hs=new Set(["empty object","free-floating scalar","invalid @language value","invalid property","null @id value","null @value value","object with only @id","object with only @language","object with only @list","object with only @value","relative @id reference","relative @type reference","relative @vocab reference","reserved @id value","reserved @reverse value","reserved term","blank node predicate","relative graph reference","relative object reference","relative predicate reference","relative subject reference","rdfDirection not set"]);G.safeEventHandler=function({event:t,next:n}){if(t.level==="warning"&&hs.has(t.code))throw new nn("Safe mode validation error.","jsonld.ValidationError",{event:t});n()};G.logEventHandler=function({event:t,next:n}){console.log(`EVENT: ${t.message}`,{event:t}),n()};G.logWarningEventHandler=function({event:t,next:n}){t.level==="warning"&&console.warn(`WARNING: ${t.message}`,{event:t}),n()};G.unhandledEventHandler=function({event:t}){throw new nn("No handler for event.","jsonld.UnhandledEvent",{event:t})};G.setDefaultEventHandler=function({eventHandler:e}={}){G.defaultEventHandler=e?Xn(e):null};const vn=ee,E=C,{isArray:Kn,isObject:me,isString:B,isUndefined:ps}=z,{isAbsolute:je,isRelative:gs,prependBase:ze}=we,{handleEvent:Je}=We,{REGEX_BCP47:ys,REGEX_KEYWORD:at,asArray:Wn,compareShortestLeast:ms}=ee,Ze=new Map,vs=1e4,O={};var Re=O;O.process=async({activeCtx:e,localCtx:t,options:n,propagate:r=!0,overrideProtected:i=!1,cycles:a=new Set})=>{if(me(t)&&"@context"in t&&Kn(t["@context"])&&(t=t["@context"]),Wn(t).length===0)return e;const o=[],c=[({event:f,next:l})=>{o.push(f),l()}];n.eventHandler&&c.push(n.eventHandler);const d=n;n={...n,eventHandler:c};const p=await n.contextResolver.resolve({activeCtx:e,context:t,documentLoader:n.documentLoader,base:n.base});me(p[0].document)&&typeof p[0].document["@propagate"]=="boolean"&&(r=p[0].document["@propagate"]);let h=e;!r&&!h.previousContext&&(h=h.clone(),h.previousContext=e);for(const f of p){let{document:l}=f;if(e=h,l===null){if(!i&&Object.keys(e.protected).length!==0)throw new E("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{code:"invalid context nullification"});h=e=O.getInitialContext(n).clone();continue}const u=f.getProcessed(e);if(u){if(d.eventHandler)for(const g of u.events)Je({event:g,options:d});h=e=u.context;continue}if(me(l)&&"@context"in l&&(l=l["@context"]),!me(l))throw new E("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{code:"invalid local context",context:l});h=h.clone();const y=new Map;if("@version"in l){if(l["@version"]!==1.1)throw new E("Unsupported JSON-LD version: "+l["@version"],"jsonld.UnsupportedVersion",{code:"invalid @version value",context:l});if(e.processingMode&&e.processingMode==="json-ld-1.0")throw new E("@version: "+l["@version"]+" not compatible with "+e.processingMode,"jsonld.ProcessingModeConflict",{code:"processing mode conflict",context:l});h.processingMode="json-ld-1.1",h["@version"]=l["@version"],y.set("@version",!0)}if(h.processingMode=h.processingMode||e.processingMode,"@base"in l){let g=l["@base"];if(!(g===null||je(g)))if(gs(g))g=ze(h["@base"],g);else throw new E('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{code:"invalid base IRI",context:l});h["@base"]=g,y.set("@base",!0)}if("@vocab"in l){const g=l["@vocab"];if(g===null)delete h["@vocab"];else if(B(g)){if(!je(g)&&O.processingMode(h,1))throw new E('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:l});{const m=ke(h,g,{vocab:!0,base:!0},void 0,void 0,n);je(m)||n.eventHandler&&Je({event:{type:["JsonLdEvent"],code:"relative @vocab reference",level:"warning",message:"Relative @vocab reference found.",details:{vocab:m}},options:n}),h["@vocab"]=m}}else throw new E('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid vocab mapping",context:l});y.set("@vocab",!0)}if("@language"in l){const g=l["@language"];if(g===null)delete h["@language"];else if(B(g))g.match(ys)||n.eventHandler&&Je({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:g}},options:n}),h["@language"]=g.toLowerCase();else throw new E('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{code:"invalid default language",context:l});y.set("@language",!0)}if("@direction"in l){const g=l["@direction"];if(e.processingMode==="json-ld-1.0")throw new E("Invalid JSON-LD syntax; @direction not compatible with "+e.processingMode,"jsonld.SyntaxError",{code:"invalid context member",context:l});if(g===null)delete h["@direction"];else{if(g!=="ltr"&&g!=="rtl")throw new E('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:l});h["@direction"]=g}y.set("@direction",!0)}if("@propagate"in l){const g=l["@propagate"];if(e.processingMode==="json-ld-1.0")throw new E("Invalid JSON-LD syntax; @propagate not compatible with "+e.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:l});if(typeof g!="boolean")throw new E("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{code:"invalid @propagate value",context:t});y.set("@propagate",!0)}if("@import"in l){const g=l["@import"];if(e.processingMode==="json-ld-1.0")throw new E("Invalid JSON-LD syntax; @import not compatible with "+e.processingMode,"jsonld.SyntaxError",{code:"invalid context entry",context:l});if(!B(g))throw new E("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{code:"invalid @import value",context:t});const m=await n.contextResolver.resolve({activeCtx:e,context:g,documentLoader:n.documentLoader,base:n.base});if(m.length!==1)throw new E("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{code:"invalid remote context",context:t});const v=m[0].getProcessed(e);if(v)l=v;else{const I=m[0].document;if("@import"in I)throw new E("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{code:"invalid context entry",context:t});for(const b in I)l.hasOwnProperty(b)||(l[b]=I[b]);m[0].setProcessed(e,l)}y.set("@import",!0)}y.set("@protected",l["@protected"]||!1);for(const g in l)if(O.createTermDefinition({activeCtx:h,localCtx:l,term:g,defined:y,options:n,overrideProtected:i}),me(l[g])&&"@context"in l[g]){const m=l[g]["@context"];let v=!0;if(B(m)){const I=ze(n.base,m);a.has(I)?v=!1:a.add(I)}if(v)try{await O.process({activeCtx:h.clone(),localCtx:l[g]["@context"],overrideProtected:!0,options:n,cycles:a})}catch{throw new E("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{code:"invalid scoped context",context:l[g]["@context"],term:g})}}f.setProcessed(e,{context:h,events:o})}return h};O.createTermDefinition=({activeCtx:e,localCtx:t,term:n,defined:r,options:i,overrideProtected:a=!1})=>{if(r.has(n)){if(r.get(n))return;throw new E("Cyclical context definition detected.","jsonld.CyclicalContext",{code:"cyclic IRI mapping",context:t,term:n})}r.set(n,!1);let s;if(t.hasOwnProperty(n)&&(s=t[n]),n==="@type"&&me(s)&&(s["@container"]||"@set")==="@set"&&O.processingMode(e,1.1)){const l=["@container","@id","@protected"],u=Object.keys(s);if(u.length===0||u.some(y=>!l.includes(y)))throw new E("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:t,term:n})}else{if(O.isKeyword(n))throw new E("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{code:"keyword redefinition",context:t,term:n});if(n.match(at)){i.eventHandler&&Je({event:{type:["JsonLdEvent"],code:"reserved term",level:"warning",message:'Terms beginning with "@" are reserved for future use and dropped.',details:{term:n}},options:i});return}else if(n==="")throw new E("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{code:"invalid term definition",context:t})}const o=e.mappings.get(n);e.mappings.has(n)&&e.mappings.delete(n);let c=!1;if((B(s)||s===null)&&(c=!0,s={"@id":s}),!me(s))throw new E("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{code:"invalid term definition",context:t});const d={};e.mappings.set(n,d),d.reverse=!1;const p=["@container","@id","@language","@reverse","@type"];O.processingMode(e,1.1)&&p.push("@context","@direction","@index","@nest","@prefix","@protected");for(const l in s)if(!p.includes(l))throw new E("Invalid JSON-LD syntax; a term definition must not contain "+l,"jsonld.SyntaxError",{code:"invalid term definition",context:t});const h=n.indexOf(":");if(d._termHasColon=h>0,"@reverse"in s){if("@id"in s)throw new E("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});if("@nest"in s)throw new E("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});const l=s["@reverse"];if(!B(l))throw new E("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});if(l.match(at)){i.eventHandler&&Je({event:{type:["JsonLdEvent"],code:"reserved @reverse value",level:"warning",message:'@reverse values beginning with "@" are reserved for future use and dropped.',details:{reverse:l}},options:i}),o?e.mappings.set(n,o):e.mappings.delete(n);return}const u=ke(e,l,{vocab:!0,base:!1},t,r,i);if(!je(u))throw new E("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});d["@id"]=u,d.reverse=!0}else if("@id"in s){let l=s["@id"];if(l&&!B(l))throw new E("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});if(l===null)d["@id"]=null;else if(!O.isKeyword(l)&&l.match(at)){i.eventHandler&&Je({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:'@id values beginning with "@" are reserved for future use and dropped.',details:{id:l}},options:i}),o?e.mappings.set(n,o):e.mappings.delete(n);return}else if(l!==n){if(l=ke(e,l,{vocab:!0,base:!1},t,r,i),!je(l)&&!O.isKeyword(l))throw new E("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t});if(n.match(/(?::[^:])|\//)){const u=new Map(r).set(n,!0);if(ke(e,n,{vocab:!0,base:!1},t,u,i)!==l)throw new E("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t})}d["@id"]=l,d._prefix=c&&!d._termHasColon&&l.match(/[:\/\?#\[\]@]$/)!==null}}if(!("@id"in d))if(d._termHasColon){const l=n.substr(0,h);if(t.hasOwnProperty(l)&&O.createTermDefinition({activeCtx:e,localCtx:t,term:l,defined:r,options:i}),e.mappings.has(l)){const u=n.substr(h+1);d["@id"]=e.mappings.get(l)["@id"]+u}else d["@id"]=n}else if(n==="@type")d["@id"]=n;else{if(!("@vocab"in e))throw new E("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{code:"invalid IRI mapping",context:t,term:n});d["@id"]=e["@vocab"]+n}if((s["@protected"]===!0||r.get("@protected")===!0&&s["@protected"]!==!1)&&(e.protected[n]=!0,d.protected=!0),r.set(n,!0),"@type"in s){let l=s["@type"];if(!B(l))throw new E("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{code:"invalid type mapping",context:t});if(l==="@json"||l==="@none"){if(O.processingMode(e,1))throw new E(`Invalid JSON-LD syntax; an @context @type value must not be "${l}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{code:"invalid type mapping",context:t})}else if(l!=="@id"&&l!=="@vocab"){if(l=ke(e,l,{vocab:!0,base:!1},t,r,i),!je(l))throw new E("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{code:"invalid type mapping",context:t});if(l.indexOf("_:")===0)throw new E("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{code:"invalid type mapping",context:t})}d["@type"]=l}if("@container"in s){const l=B(s["@container"])?[s["@container"]]:s["@container"]||[],u=["@list","@set","@index","@language"];let y=!0;const g=l.includes("@set");if(O.processingMode(e,1.1)){if(u.push("@graph","@id","@type"),l.includes("@list")){if(l.length!==1)throw new E("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{code:"invalid container mapping",context:t})}else if(l.includes("@graph")){if(l.some(m=>m!=="@graph"&&m!=="@id"&&m!=="@index"&&m!=="@set"))throw new E("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{code:"invalid container mapping",context:t})}else y&=l.length<=(g?2:1);if(l.includes("@type")&&(d["@type"]=d["@type"]||"@id",!["@id","@vocab"].includes(d["@type"])))throw new E("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{code:"invalid type mapping",context:t})}else y&=!Kn(s["@container"]),y&=l.length<=1;if(y&=l.every(m=>u.includes(m)),y&=!(g&&l.includes("@list")),!y)throw new E("Invalid JSON-LD syntax; @context @container value must be one of the following: "+u.join(", "),"jsonld.SyntaxError",{code:"invalid container mapping",context:t});if(d.reverse&&!l.every(m=>["@index","@set"].includes(m)))throw new E("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{code:"invalid reverse property",context:t});d["@container"]=l}if("@index"in s){if(!("@container"in s)||!d["@container"].includes("@index"))throw new E(`Invalid JSON-LD syntax; @index without @index in @container: "${s["@index"]}" on term "${n}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:t});if(!B(s["@index"])||s["@index"].indexOf("@")===0)throw new E(`Invalid JSON-LD syntax; @index must expand to an IRI: "${s["@index"]}" on term "${n}".`,"jsonld.SyntaxError",{code:"invalid term definition",context:t});d["@index"]=s["@index"]}if("@context"in s&&(d["@context"]=s["@context"]),"@language"in s&&!("@type"in s)){let l=s["@language"];if(l!==null&&!B(l))throw new E("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{code:"invalid language mapping",context:t});l!==null&&(l=l.toLowerCase()),d["@language"]=l}if("@prefix"in s){if(n.match(/:|\//))throw new E("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{code:"invalid term definition",context:t});if(O.isKeyword(d["@id"]))throw new E("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{code:"invalid term definition",context:t});if(typeof s["@prefix"]=="boolean")d._prefix=s["@prefix"]===!0;else throw new E("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{code:"invalid @prefix value",context:t})}if("@direction"in s){const l=s["@direction"];if(l!==null&&l!=="ltr"&&l!=="rtl")throw new E('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",context:t});d["@direction"]=l}if("@nest"in s){const l=s["@nest"];if(!B(l)||l!=="@nest"&&l.indexOf("@")===0)throw new E("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{code:"invalid @nest value",context:t});d["@nest"]=l}// disallow aliasing @context and @preserve
const f=d["@id"];if(f==="@context"||f==="@preserve")throw new E("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{code:"invalid keyword alias",context:t});if(o&&o.protected&&!a&&(e.protected[n]=!0,d.protected=!0,!Ut(o,d)))throw new E("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{code:"protected term redefinition",context:t,term:n})};O.expandIri=(e,t,n,r)=>ke(e,t,n,void 0,void 0,r);function ke(e,t,n,r,i,a){if(t===null||!B(t)||O.isKeyword(t))return t;if(t.match(at))return null;if(r&&r.hasOwnProperty(t)&&i.get(t)!==!0&&O.createTermDefinition({activeCtx:e,localCtx:r,term:t,defined:i,options:a}),n=n||{},n.vocab){const o=e.mappings.get(t);if(o===null)return null;if(me(o)&&"@id"in o)return o["@id"]}const s=t.indexOf(":");if(s>0){const o=t.substr(0,s),c=t.substr(s+1);if(o==="_"||c.indexOf("//")===0)return t;r&&r.hasOwnProperty(o)&&O.createTermDefinition({activeCtx:e,localCtx:r,term:o,defined:i,options:a});const d=e.mappings.get(o);if(d&&d._prefix)return d["@id"]+c;if(je(t))return t}if(n.vocab&&"@vocab"in e)t=e["@vocab"]+t;else if(n.base){let o,c;"@base"in e?e["@base"]?(c=ze(a.base,e["@base"]),o=ze(c,t)):(c=e["@base"],o=t):(c=a.base,o=ze(a.base,t)),t=o}return t}O.getInitialContext=e=>{const t=JSON.stringify({processingMode:e.processingMode}),n=Ze.get(t);if(n)return n;const r={processingMode:e.processingMode,mappings:new Map,inverse:null,getInverse:i,clone:o,revertToPreviousContext:c,protected:{}};return Ze.size===vs&&Ze.clear(),Ze.set(t,r),r;function i(){const d=this;if(d.inverse)return d.inverse;const p=d.inverse={},h=d.fastCurieMap={},f={},l=(d["@language"]||"@none").toLowerCase(),u=d["@direction"],y=d.mappings,g=[...y.keys()].sort(ms);for(const m of g){const v=y.get(m);if(v===null)continue;let I=v["@container"]||"@none";if(I=[].concat(I).sort().join(""),v["@id"]===null)continue;const b=Wn(v["@id"]);for(const x of b){let w=p[x];const T=O.isKeyword(x);if(w)!T&&!v._termHasColon&&f[x].push(m);else if(p[x]=w={},!T&&!v._termHasColon){f[x]=[m];const D={iri:x,terms:f[x]};x[0]in h?h[x[0]].push(D):h[x[0]]=[D]}if(w[I]||(w[I]={"@language":{},"@type":{},"@any":{}}),w=w[I],s(m,w["@any"],"@none"),v.reverse)s(m,w["@type"],"@reverse");else if(v["@type"]==="@none")s(m,w["@any"],"@none"),s(m,w["@language"],"@none"),s(m,w["@type"],"@none");else if("@type"in v)s(m,w["@type"],v["@type"]);else if("@language"in v&&"@direction"in v){const D=v["@language"],A=v["@direction"];D&&A?s(m,w["@language"],`${D}_${A}`.toLowerCase()):D?s(m,w["@language"],D.toLowerCase()):A?s(m,w["@language"],`_${A}`):s(m,w["@language"],"@null")}else"@language"in v?s(m,w["@language"],(v["@language"]||"@null").toLowerCase()):"@direction"in v?v["@direction"]?s(m,w["@language"],`_${v["@direction"]}`):s(m,w["@language"],"@none"):u?(s(m,w["@language"],`_${u}`),s(m,w["@language"],"@none"),s(m,w["@type"],"@none")):(s(m,w["@language"],l),s(m,w["@language"],"@none"),s(m,w["@type"],"@none"))}}for(const m in h)a(h,m,1);return p}function a(d,p,h){const f=d[p],l=d[p]={};let u,y;for(const g of f)u=g.iri,h>=u.length?y="":y=u[h],y in l?l[y].push(g):l[y]=[g];for(const g in l)g!==""&&a(l,g,h+1)}function s(d,p,h){p.hasOwnProperty(h)||(p[h]=d)}function o(){const d={};return d.mappings=vn.clone(this.mappings),d.clone=this.clone,d.inverse=null,d.getInverse=this.getInverse,d.protected=vn.clone(this.protected),this.previousContext&&(d.previousContext=this.previousContext.clone()),d.revertToPreviousContext=this.revertToPreviousContext,"@base"in this&&(d["@base"]=this["@base"]),"@language"in this&&(d["@language"]=this["@language"]),"@vocab"in this&&(d["@vocab"]=this["@vocab"]),d}function c(){return this.previousContext?this.previousContext.clone():this}};O.getContextValue=(e,t,n)=>{if(t===null)return n==="@context"?void 0:null;if(e.mappings.has(t)){const r=e.mappings.get(t);if(ps(n))return r;if(r.hasOwnProperty(n))return r[n]}if(n==="@language"&&n in e||n==="@direction"&&n in e)return e[n];if(n!=="@context")return null};O.processingMode=(e,t)=>t.toString()>="1.1"?!e.processingMode||e.processingMode>="json-ld-"+t.toString():e.processingMode==="json-ld-1.0";O.isKeyword=e=>{if(!B(e)||e[0]!=="@")return!1;switch(e){case"@base":case"@container":case"@context":case"@default":case"@direction":case"@embed":case"@explicit":case"@graph":case"@id":case"@included":case"@index":case"@json":case"@language":case"@list":case"@nest":case"@none":case"@omitDefault":case"@prefix":case"@preserve":case"@protected":case"@requireAll":case"@reverse":case"@set":case"@type":case"@value":case"@version":case"@vocab":return!0}return!1};function Ut(e,t){if(!(e&&typeof e=="object")||!(t&&typeof t=="object"))return e===t;const n=Array.isArray(e);if(n!==Array.isArray(t))return!1;if(n){if(e.length!==t.length)return!1;for(let a=0;a<e.length;++a)if(!Ut(e[a],t[a]))return!1;return!0}const r=Object.keys(e),i=Object.keys(t);if(r.length!==i.length)return!1;for(const a in e){let s=e[a],o=t[a];if(a==="@container"&&Array.isArray(s)&&Array.isArray(o)&&(s=s.slice().sort(),o=o.slice().sort()),!Ut(s,o))return!1}return!0}const R=C,{isArray:Y,isObject:X,isEmptyObject:qt,isString:$,isUndefined:ft}=z,{isList:_t,isValue:Vt,isGraph:bs,isSubject:ws}=pe,{expandIri:L,getContextValue:V,isKeyword:Gt,process:Xe,processingMode:ot}=Re,{isAbsolute:lt}=we,{REGEX_BCP47:Yn,REGEX_KEYWORD:Is,addValue:q,asArray:re,getValues:xs,validateTypeValue:Es}=ee,{handleEvent:K}=We,ve={};var Ns=ve;ve.expand=async({activeCtx:e,activeProperty:t=null,element:n,options:r={},insideList:i=!1,insideIndex:a=!1,typeScopedContext:s=null})=>{if(n==null)return null;if(t==="@default"&&(r=Object.assign({},r,{isFrame:!1})),!Y(n)&&!X(n))return!i&&(t===null||L(e,t,{vocab:!0},r)==="@graph")?(r.eventHandler&&K({event:{type:["JsonLdEvent"],code:"free-floating scalar",level:"warning",message:"Dropping free-floating scalar not in a list.",details:{value:n}},options:r}),null):er({activeCtx:e,activeProperty:t,value:n,options:r});if(Y(n)){let u=[];const y=V(e,t,"@container")||[];i=i||y.includes("@list");for(let g=0;g<n.length;++g){let m=await ve.expand({activeCtx:e,activeProperty:t,element:n[g],options:r,insideIndex:a,typeScopedContext:s});i&&Y(m)&&(m={"@list":m}),m!==null&&(Y(m)?u=u.concat(m):u.push(m))}return u}const o=L(e,t,{vocab:!0},r),c=V(e,t,"@context");s=s||(e.previousContext?e:null);let d=Object.keys(n).sort(),p=!a;if(p&&s&&d.length<=2&&!d.includes("@context"))for(const u of d){const y=L(s,u,{vocab:!0},r);if(y==="@value"){p=!1,e=s;break}if(y==="@id"&&d.length===1){p=!1;break}}p&&(e=e.revertToPreviousContext()),ft(c)||(e=await Xe({activeCtx:e,localCtx:c,propagate:!0,overrideProtected:!0,options:r})),"@context"in n&&(e=await Xe({activeCtx:e,localCtx:n["@context"],options:r})),s=e;let h=null;for(const u of d)if(L(e,u,{vocab:!0},r)==="@type"){h=h||u;const g=n[u],m=Array.isArray(g)?g.length>1?g.slice().sort():g:[g];for(const v of m){const I=V(s,v,"@context");ft(I)||(e=await Xe({activeCtx:e,localCtx:I,options:r,propagate:!1}))}}let f={};await Cn({activeCtx:e,activeProperty:t,expandedActiveProperty:o,element:n,expandedParent:f,options:r,insideList:i,typeKey:h,typeScopedContext:s}),d=Object.keys(f);let l=d.length;if("@value"in f){if("@type"in f&&("@language"in f||"@direction"in f))throw new R('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:f});let u=l-1;if("@type"in f&&(u-=1),"@index"in f&&(u-=1),"@language"in f&&(u-=1),"@direction"in f&&(u-=1),u!==0)throw new R('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{code:"invalid value object",element:f});const y=f["@value"]===null?[]:re(f["@value"]),g=xs(f,"@type");if(!(ot(e,1.1)&&g.includes("@json")&&g.length===1))if(y.length===0)r.eventHandler&&K({event:{type:["JsonLdEvent"],code:"null @value value",level:"warning",message:"Dropping null @value value.",details:{value:f}},options:r}),f=null;else{if(!y.every(m=>$(m)||qt(m))&&"@language"in f)throw new R("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{code:"invalid language-tagged value",element:f});if(!g.every(m=>lt(m)&&!($(m)&&m.indexOf("_:")===0)||qt(m)))throw new R('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{code:"invalid typed value",element:f})}}else if("@type"in f&&!Y(f["@type"]))f["@type"]=[f["@type"]];else if("@set"in f||"@list"in f){if(l>1&&!(l===2&&"@index"in f))throw new R('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{code:"invalid set or list object",element:f});"@set"in f&&(f=f["@set"],d=Object.keys(f),l=d.length)}else l===1&&"@language"in f&&(r.eventHandler&&K({event:{type:["JsonLdEvent"],code:"object with only @language",level:"warning",message:"Dropping object with only @language.",details:{value:f}},options:r}),f=null);return X(f)&&!r.keepFreeFloatingNodes&&!i&&(t===null||o==="@graph"||(V(e,t,"@container")||[]).includes("@graph"))&&(f=Zn({value:f,count:l,options:r})),f};function Zn({value:e,count:t,options:n}){if(t===0||"@value"in e||"@list"in e||t===1&&"@id"in e){if(n.eventHandler){let r,i;t===0?(r="empty object",i="Dropping empty object."):"@value"in e?(r="object with only @value",i="Dropping object with only @value."):"@list"in e?(r="object with only @list",i="Dropping object with only @list."):t===1&&"@id"in e&&(r="object with only @id",i="Dropping object with only @id."),K({event:{type:["JsonLdEvent"],code:r,level:"warning",message:i,details:{value:e}},options:n})}return null}return e}async function Cn({activeCtx:e,activeProperty:t,expandedActiveProperty:n,element:r,expandedParent:i,options:a={},insideList:s,typeKey:o,typeScopedContext:c}){const d=Object.keys(r).sort(),p=[];let h;const f=r[o]&&L(e,Y(r[o])?r[o][0]:r[o],{vocab:!0},{...a,typeExpansion:!0})==="@json";for(const l of d){let u=r[l],y;if(l==="@context")continue;const g=L(e,l,{vocab:!0},a);if(g===null||!(lt(g)||Gt(g))){a.eventHandler&&K({event:{type:["JsonLdEvent"],code:"invalid property",level:"warning",message:"Dropping property that did not expand into an absolute IRI or keyword.",details:{property:l,expandedProperty:g}},options:a});continue}if(Gt(g)){if(n==="@reverse")throw new R("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{code:"invalid reverse property map",value:u});if(g in i&&g!=="@included"&&g!=="@type")throw new R("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{code:"colliding keywords",keyword:g})}if(g==="@id"){if(!$(u)){if(!a.isFrame)throw new R('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{code:"invalid @id value",value:u});if(X(u)){if(!qt(u))throw new R('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:u})}else if(Y(u)){if(!u.every(b=>$(b)))throw new R('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:u})}else throw new R('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{code:"invalid @id value",value:u})}q(i,"@id",re(u).map(b=>{if($(b)){const x=L(e,b,{base:!0},a);return a.eventHandler&&(x===null?K(b===null?{event:{type:["JsonLdEvent"],code:"null @id value",level:"warning",message:"Null @id found.",details:{id:b}},options:a}:{event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:b}},options:a}):lt(x)||K({event:{type:["JsonLdEvent"],code:"relative @id reference",level:"warning",message:"Relative @id reference found.",details:{id:b,expandedId:x}},options:a})),x}return b}),{propertyIsArray:a.isFrame});continue}if(g==="@type"){X(u)&&(u=Object.fromEntries(Object.entries(u).map(([b,x])=>[L(c,b,{vocab:!0}),re(x).map(w=>L(c,w,{base:!0,vocab:!0},{...a,typeExpansion:!0}))]))),Es(u,a.isFrame),q(i,"@type",re(u).map(b=>{if($(b)){const x=L(c,b,{base:!0,vocab:!0},{...a,typeExpansion:!0});return x!=="@json"&&!lt(x)&&a.eventHandler&&K({event:{type:["JsonLdEvent"],code:"relative @type reference",level:"warning",message:"Relative @type reference found.",details:{type:b}},options:a}),x}return b}),{propertyIsArray:!!a.isFrame});continue}if(g==="@included"&&ot(e,1.1)){const b=re(await ve.expand({activeCtx:e,activeProperty:t,element:u,options:a}));if(!b.every(x=>ws(x)))throw new R("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{code:"invalid @included value",value:u});q(i,"@included",b,{propertyIsArray:!0});continue}if(g==="@graph"&&!(X(u)||Y(u)))throw new R('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid @graph value",value:u});if(g==="@value"){h=u,f&&ot(e,1.1)?i["@value"]=u:q(i,"@value",u,{propertyIsArray:a.isFrame});continue}if(g==="@language"){if(u===null)continue;if(!$(u)&&!a.isFrame)throw new R('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{code:"invalid language-tagged string",value:u});u=re(u).map(b=>$(b)?b.toLowerCase():b);for(const b of u)$(b)&&!b.match(Yn)&&a.eventHandler&&K({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:b}},options:a});q(i,"@language",u,{propertyIsArray:a.isFrame});continue}if(g==="@direction"){if(!$(u)&&!a.isFrame)throw new R('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{code:"invalid base direction",value:u});u=re(u);for(const b of u)if($(b)&&b!=="ltr"&&b!=="rtl")throw new R('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{code:"invalid base direction",value:u});q(i,"@direction",u,{propertyIsArray:a.isFrame});continue}if(g==="@index"){if(!$(u))throw new R('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{code:"invalid @index value",value:u});q(i,"@index",u);continue}if(g==="@reverse"){if(!X(u))throw new R('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{code:"invalid @reverse value",value:u});if(y=await ve.expand({activeCtx:e,activeProperty:"@reverse",element:u,options:a}),"@reverse"in y)for(const x in y["@reverse"])q(i,x,y["@reverse"][x],{propertyIsArray:!0});let b=i["@reverse"]||null;for(const x in y){if(x==="@reverse")continue;b===null&&(b=i["@reverse"]={}),q(b,x,[],{propertyIsArray:!0});const w=y[x];for(let T=0;T<w.length;++T){const D=w[T];if(Vt(D)||_t(D))throw new R('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:y});q(b,x,D,{propertyIsArray:!0})}}continue}if(g==="@nest"){p.push(l);continue}let m=e;const v=V(e,l,"@context");ft(v)||(m=await Xe({activeCtx:e,localCtx:v,propagate:!0,overrideProtected:!0,options:a}));const I=V(e,l,"@container")||[];if(I.includes("@language")&&X(u)){const b=V(m,l,"@direction");y=_s(m,u,b,a)}else if(I.includes("@index")&&X(u)){const b=I.includes("@graph"),x=V(m,l,"@index")||"@index",w=x!=="@index"&&L(e,x,{vocab:!0},a);y=await jt({activeCtx:m,options:a,activeProperty:l,value:u,asGraph:b,indexKey:x,propertyIndex:w})}else if(I.includes("@id")&&X(u)){const b=I.includes("@graph");y=await jt({activeCtx:m,options:a,activeProperty:l,value:u,asGraph:b,indexKey:"@id"})}else if(I.includes("@type")&&X(u))y=await jt({activeCtx:m.revertToPreviousContext(),options:a,activeProperty:l,value:u,asGraph:!1,indexKey:"@type"});else{const b=g==="@list";if(b||g==="@set"){let x=t;b&&n==="@graph"&&(x=null),y=await ve.expand({activeCtx:m,activeProperty:x,element:u,options:a,insideList:b})}else V(e,l,"@type")==="@json"?y={"@type":"@json","@value":u}:y=await ve.expand({activeCtx:m,activeProperty:l,element:u,options:a,insideList:!1})}if(!(y===null&&g!=="@value")){if(g!=="@list"&&!_t(y)&&I.includes("@list")&&(y={"@list":re(y)}),I.includes("@graph")&&!I.some(b=>b==="@id"||b==="@index")){if(y=re(y),a.isFrame||(y=y.filter(b=>{const x=Object.keys(b).length;return Zn({value:b,count:x,options:a})!==null})),y.length===0)continue;y=y.map(b=>({"@graph":re(b)}))}if(m.mappings.has(l)&&m.mappings.get(l).reverse){const b=i["@reverse"]=i["@reverse"]||{};y=re(y);for(let x=0;x<y.length;++x){const w=y[x];if(Vt(w)||_t(w))throw new R('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{code:"invalid reverse property value",value:y});q(b,g,w,{propertyIsArray:!0})}continue}q(i,g,y,{propertyIsArray:!0})}}if("@value"in i&&!(i["@type"]==="@json"&&ot(e,1.1))){if((X(h)||Y(h))&&!a.isFrame)throw new R('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{code:"invalid value object value",value:h})}for(const l of p){const u=Y(r[l])?r[l]:[r[l]];for(const y of u){if(!X(y)||Object.keys(y).some(g=>L(e,g,{vocab:!0},a)==="@value"))throw new R("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{code:"invalid @nest value",value:y});await Cn({activeCtx:e,activeProperty:t,expandedActiveProperty:n,element:y,expandedParent:i,options:a,insideList:s,typeScopedContext:c,typeKey:o})}}}function er({activeCtx:e,activeProperty:t,value:n,options:r}){if(n==null)return null;const i=L(e,t,{vocab:!0},r);if(i==="@id")return L(e,n,{base:!0},r);if(i==="@type")return L(e,n,{vocab:!0,base:!0},{...r,typeExpansion:!0});const a=V(e,t,"@type");if((a==="@id"||i==="@graph")&&$(n)){const o=L(e,n,{base:!0},r);return o===null&&n.match(Is)&&r.eventHandler&&K({event:{type:["JsonLdEvent"],code:"reserved @id value",level:"warning",message:"Reserved @id found.",details:{id:t}},options:r}),{"@id":o}}if(a==="@vocab"&&$(n))return{"@id":L(e,n,{vocab:!0,base:!0},r)};if(Gt(i))return n;const s={};if(a&&!["@id","@vocab","@none"].includes(a))s["@type"]=a;else if($(n)){const o=V(e,t,"@language");o!==null&&(s["@language"]=o);const c=V(e,t,"@direction");c!==null&&(s["@direction"]=c)}return["boolean","number","string"].includes(typeof n)||(n=n.toString()),s["@value"]=n,s}function _s(e,t,n,r){const i=[],a=Object.keys(t).sort();for(const s of a){const o=L(e,s,{vocab:!0},r);let c=t[s];Y(c)||(c=[c]);for(const d of c){if(d===null)continue;if(!$(d))throw new R("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{code:"invalid language map value",languageMap:t});const p={"@value":d};o!=="@none"&&(s.match(Yn)||r.eventHandler&&K({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:s}},options:r}),p["@language"]=s.toLowerCase()),n&&(p["@direction"]=n),i.push(p)}}return i}async function jt({activeCtx:e,options:t,activeProperty:n,value:r,asGraph:i,indexKey:a,propertyIndex:s}){const o=[],c=Object.keys(r).sort(),d=a==="@type";for(let p of c){if(d){const l=V(e,p,"@context");ft(l)||(e=await Xe({activeCtx:e,localCtx:l,propagate:!1,options:t}))}let h=r[p];Y(h)||(h=[h]),h=await ve.expand({activeCtx:e,activeProperty:n,element:h,options:t,insideList:!1,insideIndex:!0});let f;s?p==="@none"?f="@none":f=er({activeCtx:e,activeProperty:a,value:p,options:t}):f=L(e,p,{vocab:!0},t),a==="@id"?p=L(e,p,{base:!0},t):d&&(p=f);for(let l of h){if(i&&!bs(l)&&(l={"@graph":[l]}),a==="@type")f==="@none"||(l["@type"]?l["@type"]=[p].concat(l["@type"]):l["@type"]=[p]);else{if(Vt(l)&&!["@language","@type","@index"].includes(a))throw new R(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${a}".`,"jsonld.SyntaxError",{code:"invalid value object",value:l});s?f!=="@none"&&q(l,s,f,{propertyIsArray:!0,prependValue:!0}):f!=="@none"&&!(a in l)&&(l[a]=p)}o.push(l)}}return o}const{isKeyword:tr}=Re,oe=pe,St=z,le=ee,js=C,P={};var yt=P;P.createMergedNodeMap=(e,t)=>{t=t||{};const n=t.issuer||new le.IdentifierIssuer("_:b"),r={"@default":{}};return P.createNodeMap(e,r,"@default",n),P.mergeNodeMaps(r)};P.createNodeMap=(e,t,n,r,i,a)=>{if(St.isArray(e)){for(const d of e)P.createNodeMap(d,t,n,r,void 0,a);return}if(!St.isObject(e)){a&&a.push(e);return}if(oe.isValue(e)){if("@type"in e){let d=e["@type"];d.indexOf("_:")===0&&(e["@type"]=d=r.getId(d))}a&&a.push(e);return}else if(a&&oe.isList(e)){const d=[];P.createNodeMap(e["@list"],t,n,r,i,d),a.push({"@list":d});return}if("@type"in e){const d=e["@type"];for(const p of d)p.indexOf("_:")===0&&r.getId(p)}St.isUndefined(i)&&(i=oe.isBlankNode(e)?r.getId(e["@id"]):e["@id"]),a&&a.push({"@id":i});const s=t[n],o=s[i]=s[i]||{};o["@id"]=i;const c=Object.keys(e).sort();for(let d of c){if(d==="@id")continue;if(d==="@reverse"){const h={"@id":i},f=e["@reverse"];for(const l in f){const u=f[l];for(const y of u){let g=y["@id"];oe.isBlankNode(y)&&(g=r.getId(g)),P.createNodeMap(y,t,n,r,g),le.addValue(s[g],l,h,{propertyIsArray:!0,allowDuplicate:!1})}}continue}if(d==="@graph"){i in t||(t[i]={}),P.createNodeMap(e[d],t,i,r);continue}if(d==="@included"){P.createNodeMap(e[d],t,n,r);continue}if(d!=="@type"&&tr(d)){if(d==="@index"&&d in o&&(e[d]!==o[d]||e[d]["@id"]!==o[d]["@id"]))throw new js("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{code:"conflicting indexes",subject:o});o[d]=e[d];continue}const p=e[d];if(d.indexOf("_:")===0&&(d=r.getId(d)),p.length===0){le.addValue(o,d,[],{propertyIsArray:!0});continue}for(let h of p)if(d==="@type"&&(h=h.indexOf("_:")===0?r.getId(h):h),oe.isSubject(h)||oe.isSubjectReference(h)){if("@id"in h&&!h["@id"])continue;const f=oe.isBlankNode(h)?r.getId(h["@id"]):h["@id"];le.addValue(o,d,{"@id":f},{propertyIsArray:!0,allowDuplicate:!1}),P.createNodeMap(h,t,n,r,f)}else if(oe.isValue(h))le.addValue(o,d,h,{propertyIsArray:!0,allowDuplicate:!1});else if(oe.isList(h)){const f=[];P.createNodeMap(h["@list"],t,n,r,i,f),h={"@list":f},le.addValue(o,d,h,{propertyIsArray:!0,allowDuplicate:!1})}else P.createNodeMap(h,t,n,r,i),le.addValue(o,d,h,{propertyIsArray:!0,allowDuplicate:!1})}};P.mergeNodeMapGraphs=e=>{const t={};for(const n of Object.keys(e).sort())for(const r of Object.keys(e[n]).sort()){const i=e[n][r];r in t||(t[r]={"@id":r});const a=t[r];for(const s of Object.keys(i).sort())if(tr(s)&&s!=="@type")a[s]=le.clone(i[s]);else for(const o of i[s])le.addValue(a,s,le.clone(o),{propertyIsArray:!0,allowDuplicate:!1})}return t};P.mergeNodeMaps=e=>{const t=e["@default"],n=Object.keys(e).sort();for(const r of n){if(r==="@default")continue;const i=e[r];let a=t[r];a?"@graph"in a||(a["@graph"]=[]):t[r]=a={"@id":r,"@graph":[]};const s=a["@graph"];for(const o of Object.keys(i).sort()){const c=i[o];oe.isSubjectReference(c)||s.push(c)}}return t};const{isSubjectReference:Ss}=pe,{createMergedNodeMap:Ds}=yt,nr={};var Os=nr;nr.flatten=e=>{const t=Ds(e),n=[],r=Object.keys(t).sort();for(let i=0;i<r.length;++i){const a=t[r[i]];Ss(a)||n.push(a)}return n};const zt=C,Dt=pe,qe=z,{REGEX_BCP47:bn,addValue:wn}=ee,{handleEvent:In}=We,{RDF_LIST:Rs,RDF_FIRST:Ot,RDF_REST:Rt,RDF_NIL:Lt,RDF_TYPE:Ls,RDF_JSON_LITERAL:As,XSD_BOOLEAN:xn,XSD_DOUBLE:En,XSD_INTEGER:Nn,XSD_STRING:At}=en,rr={};var Ts=rr;rr.fromRDF=async(e,t)=>{const{useRdfType:n=!1,useNativeTypes:r=!1,rdfDirection:i=null}=t,a={},s={"@default":a},o={};if(i){if(i==="compound-literal")throw new zt("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:i});if(i!=="i18n-datatype")throw new zt("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:i})}for(const p of e){const h=p.graph.termType==="DefaultGraph"?"@default":p.graph.value;h in s||(s[h]={}),h!=="@default"&&!(h in a)&&(a[h]={"@id":h});const f=s[h],l=p.subject.value,u=p.predicate.value,y=p.object;l in f||(f[l]={"@id":l});const g=f[l],m=y.termType.endsWith("Node");if(m&&!(y.value in f)&&(f[y.value]={"@id":y.value}),u===Ls&&!n&&m){wn(g,"@type",y.value,{propertyIsArray:!0});continue}const v=ks(y,r,i,t);if(wn(g,u,v,{propertyIsArray:!0}),m)if(y.value===Lt){const I=f[y.value];"usages"in I||(I.usages=[]),I.usages.push({node:g,property:u,value:v})}else y.value in o?o[y.value]=!1:o[y.value]={node:g,property:u,value:v}}for(const p in s){const h=s[p];if(!(Lt in h))continue;const f=h[Lt];if(f.usages){for(let l of f.usages){let u=l.node,y=l.property,g=l.value;const m=[],v=[];let I=Object.keys(u).length;for(;y===Rt&&qe.isObject(o[u["@id"]])&&qe.isArray(u[Ot])&&u[Ot].length===1&&qe.isArray(u[Rt])&&u[Rt].length===1&&(I===3||I===4&&qe.isArray(u["@type"])&&u["@type"].length===1&&u["@type"][0]===Rs)&&(m.push(u[Ot][0]),v.push(u["@id"]),l=o[u["@id"]],u=l.node,y=l.property,g=l.value,I=Object.keys(u).length,!!Dt.isBlankNode(u)););delete g["@id"],g["@list"]=m.reverse();for(const b of v)delete h[b]}delete f.usages}}const c=[],d=Object.keys(a).sort();for(const p of d){const h=a[p];if(p in s){const f=h["@graph"]=[],l=s[p],u=Object.keys(l).sort();for(const y of u){const g=l[y];Dt.isSubjectReference(g)||f.push(g)}}Dt.isSubjectReference(h)||c.push(h)}return c};function ks(e,t,n,r){if(e.termType.endsWith("Node"))return{"@id":e.value};const i={"@value":e.value};if(e.language)e.language.match(bn)||r.eventHandler&&In({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:e.language}},options:r}),i["@language"]=e.language;else{let a=e.datatype.value;if(a||(a=At),a===As){a="@json";try{i["@value"]=JSON.parse(i["@value"])}catch(s){throw new zt("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{code:"invalid JSON literal",value:i["@value"],cause:s})}}if(t){if(a===xn)i["@value"]==="true"?i["@value"]=!0:i["@value"]==="false"&&(i["@value"]=!1);else if(qe.isNumeric(i["@value"]))if(a===Nn){const s=parseInt(i["@value"],10);s.toFixed(0)===i["@value"]&&(i["@value"]=s)}else a===En&&(i["@value"]=parseFloat(i["@value"]));[xn,Nn,En,At].includes(a)||(i["@type"]=a)}else if(n==="i18n-datatype"&&a.startsWith("https://www.w3.org/ns/i18n#")){const[,s,o]=a.split(/[#_]/);s.length>0&&(i["@language"]=s,s.match(bn)||r.eventHandler&&In({event:{type:["JsonLdEvent"],code:"invalid @language value",level:"warning",message:"@language value must be valid BCP47.",details:{language:s}},options:r})),i["@direction"]=o}else a!==At&&(i["@type"]=a)}return i}var Ms=function e(t){return t===null||typeof t!="object"||t.toJSON!=null?JSON.stringify(t):Array.isArray(t)?"["+t.reduce((n,r,i)=>{const a=i===0?"":",",s=r===void 0||typeof r=="symbol"?null:r;return n+a+e(s)},"")+"]":"{"+Object.keys(t).sort().reduce((n,r,i)=>{if(t[r]===void 0||typeof t[r]=="symbol")return n;const a=n.length===0?"":",";return n+a+e(r)+":"+e(t[r])},"")+"}"};const{createNodeMap:$s}=yt,{isKeyword:Js}=Re,_n=pe,Fs=Ms,jn=C,Be=z,Hs=ee,{handleEvent:Se}=We,{RDF_FIRST:Ps,RDF_REST:Bs,RDF_NIL:Us,RDF_TYPE:qs,RDF_JSON_LITERAL:Vs,RDF_LANGSTRING:Gs,XSD_BOOLEAN:zs,XSD_DOUBLE:Sn,XSD_INTEGER:Xs,XSD_STRING:Qs}=en,{isAbsolute:ht}=we,sr={};var Ks=sr;sr.toRDF=(e,t)=>{const n=new Hs.IdentifierIssuer("_:b"),r={"@default":{}};$s(e,r,"@default",n);const i=[],a=Object.keys(r).sort();for(const s of a){let o;if(s==="@default")o={termType:"DefaultGraph",value:""};else if(ht(s))s.startsWith("_:")?o={termType:"BlankNode"}:o={termType:"NamedNode"},o.value=s;else{t.eventHandler&&Se({event:{type:["JsonLdEvent"],code:"relative graph reference",level:"warning",message:"Relative graph reference found.",details:{graph:s}},options:t});continue}Ws(i,r[s],o,n,t)}return i};function Ws(e,t,n,r,i){const a=Object.keys(t).sort();for(const s of a){const o=t[s],c=Object.keys(o).sort();for(let d of c){const p=o[d];if(d==="@type")d=qs;else if(Js(d))continue;for(const h of p){const f={termType:s.startsWith("_:")?"BlankNode":"NamedNode",value:s};if(!ht(s)){i.eventHandler&&Se({event:{type:["JsonLdEvent"],code:"relative subject reference",level:"warning",message:"Relative subject reference found.",details:{subject:s}},options:i});continue}const l={termType:d.startsWith("_:")?"BlankNode":"NamedNode",value:d};if(!ht(d)){i.eventHandler&&Se({event:{type:["JsonLdEvent"],code:"relative predicate reference",level:"warning",message:"Relative predicate reference found.",details:{predicate:d}},options:i});continue}if(l.termType==="BlankNode"&&!i.produceGeneralizedRdf){i.eventHandler&&Se({event:{type:["JsonLdEvent"],code:"blank node predicate",level:"warning",message:"Dropping blank node predicate.",details:{property:r.getOldIds().find(y=>r.getId(y)===d)}},options:i});continue}const u=Xt(h,r,e,n,i.rdfDirection,i);u&&e.push({subject:f,predicate:l,object:u,graph:n})}}}}function Ys(e,t,n,r,i,a){const s={termType:"NamedNode",value:Ps},o={termType:"NamedNode",value:Bs},c={termType:"NamedNode",value:Us},d=e.pop(),p=d?{termType:"BlankNode",value:t.getId()}:c;let h=p;for(const f of e){const l=Xt(f,t,n,r,i,a),u={termType:"BlankNode",value:t.getId()};n.push({subject:h,predicate:s,object:l,graph:r}),n.push({subject:h,predicate:o,object:u,graph:r}),h=u}if(d){const f=Xt(d,t,n,r,i,a);n.push({subject:h,predicate:s,object:f,graph:r}),n.push({subject:h,predicate:o,object:c,graph:r})}return p}function Xt(e,t,n,r,i,a){const s={};if(_n.isValue(e)){s.termType="Literal",s.value=void 0,s.datatype={termType:"NamedNode"};let o=e["@value"];const c=e["@type"]||null;if(c==="@json")s.value=Fs(o),s.datatype.value=Vs;else if(Be.isBoolean(o))s.value=o.toString(),s.datatype.value=c||zs;else if(Be.isDouble(o)||c===Sn)Be.isDouble(o)||(o=parseFloat(o)),s.value=o.toExponential(15).replace(/(\d)0*e\+?/,"$1E"),s.datatype.value=c||Sn;else if(Be.isNumber(o))s.value=o.toFixed(0),s.datatype.value=c||Xs;else if("@direction"in e&&i==="i18n-datatype"){const d=(e["@language"]||"").toLowerCase(),p=e["@direction"],h=`https://www.w3.org/ns/i18n#${d}_${p}`;s.datatype.value=h,s.value=o}else{if("@direction"in e&&i==="compound-literal")throw new jn("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{value:i});if("@direction"in e&&i)throw new jn("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{value:i});"@language"in e?("@direction"in e&&!i&&a.eventHandler&&Se({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:s.value}},options:a}),s.value=o,s.datatype.value=c||Gs,s.language=e["@language"]):("@direction"in e&&!i&&a.eventHandler&&Se({event:{type:["JsonLdEvent"],code:"rdfDirection not set",level:"warning",message:"rdfDirection not set for @direction.",details:{object:s.value}},options:a}),s.value=o,s.datatype.value=c||Qs)}}else if(_n.isList(e)){const o=Ys(e["@list"],t,n,r,i,a);s.termType=o.termType,s.value=o.value}else{const o=Be.isObject(e)?e["@id"]:e;s.termType=o.startsWith("_:")?"BlankNode":"NamedNode",s.value=o}return s.termType==="NamedNode"&&!ht(s.value)?(a.eventHandler&&Se({event:{type:["JsonLdEvent"],code:"relative object reference",level:"warning",message:"Relative object reference found.",details:{object:s.value}},options:a}),null):s}const{isKeyword:Qt}=Re,Q=pe,S=z,M=ee,Dn=we,Qe=C,{createNodeMap:Zs,mergeNodeMapGraphs:Cs}=yt,W={};var ei=W;W.frameMergedOrDefault=(e,t,n)=>{const r={options:n,embedded:!1,graph:"@default",graphMap:{"@default":{}},subjectStack:[],link:{},bnodeMap:{}},i=new M.IdentifierIssuer("_:b");Zs(e,r.graphMap,"@default",i),n.merged&&(r.graphMap["@merged"]=Cs(r.graphMap),r.graph="@merged"),r.subjects=r.graphMap[r.graph];const a=[];W.frame(r,Object.keys(r.subjects).sort(),t,a),n.pruneBlankNodeIdentifiers&&(n.bnodesToClear=Object.keys(r.bnodeMap).filter(s=>r.bnodeMap[s].length===1));// remove @preserve from results
return n.link={},ct(a,n)};W.frame=(e,t,n,r,i=null)=>{ir(n),n=n[0];const a=e.options,s={embed:Ce(n,a,"embed"),explicit:Ce(n,a,"explicit"),requireAll:Ce(n,a,"requireAll")};e.link.hasOwnProperty(e.graph)||(e.link[e.graph]={});const o=e.link[e.graph],c=ni(e,t,n,s),d=Object.keys(c).sort();for(const p of d){const h=c[p];if(i===null?e.uniqueEmbeds={[e.graph]:{}}:e.uniqueEmbeds[e.graph]=e.uniqueEmbeds[e.graph]||{},s.embed==="@link"&&p in o){xe(r,i,o[p]);continue}const f={"@id":p};if(p.indexOf("_:")===0&&M.addValue(e.bnodeMap,p,f,{propertyIsArray:!0}),o[p]=f,(s.embed==="@first"||s.embed==="@last")&&e.is11)throw new Qe("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:n});if(!(!e.embedded&&e.uniqueEmbeds[e.graph].hasOwnProperty(p))){if(e.embedded&&(s.embed==="@never"||ti(h,e.graph,e.subjectStack))){xe(r,i,f);continue}if(e.embedded&&(s.embed=="@first"||s.embed=="@once")&&e.uniqueEmbeds[e.graph].hasOwnProperty(p)){xe(r,i,f);continue}if(s.embed==="@last"&&p in e.uniqueEmbeds[e.graph]&&ri(e,p),e.uniqueEmbeds[e.graph][p]={parent:r,property:i},e.subjectStack.push({subject:h,graph:e.graph}),p in e.graphMap){let l=!1,u=null;"@graph"in n?(u=n["@graph"][0],l=!(p==="@merged"||p==="@default"),S.isObject(u)||(u={})):(l=e.graph!=="@merged",u={}),l&&W.frame({...e,graph:p,embedded:!1},Object.keys(e.graphMap[p]).sort(),[u],f,"@graph")}"@included"in n&&W.frame({...e,embedded:!1},t,n["@included"],f,"@included");for(const l of Object.keys(h).sort()){if(Qt(l)){if(f[l]=M.clone(h[l]),l==="@type")for(const u of h["@type"])u.indexOf("_:")===0&&M.addValue(e.bnodeMap,u,f,{propertyIsArray:!0});continue}if(!(s.explicit&&!(l in n)))for(const u of h[l]){const y=l in n?n[l]:On(s);if(Q.isList(u)){const g=n[l]&&n[l][0]&&n[l][0]["@list"]?n[l][0]["@list"]:On(s),m={"@list":[]};xe(f,l,m);const v=u["@list"];for(const I of v)Q.isSubjectReference(I)?W.frame({...e,embedded:!0},[I["@id"]],g,m,"@list"):xe(m,"@list",M.clone(I))}else Q.isSubjectReference(u)?W.frame({...e,embedded:!0},[u["@id"]],y,f,l):Kt(y[0],u)&&xe(f,l,M.clone(u))}}for(const l of Object.keys(n).sort()){if(l==="@type"){if(!S.isObject(n[l][0])||!("@default"in n[l][0]))continue}else if(Qt(l))continue;const u=n[l][0]||{};if(!Ce(u,a,"omitDefault")&&!(l in f)){let g="@null";"@default"in u&&(g=M.clone(u["@default"])),S.isArray(g)||(g=[g]),f[l]=[{"@preserve":g}]}}for(const l of Object.keys(n["@reverse"]||{}).sort()){const u=n["@reverse"][l];for(const y of Object.keys(e.subjects))M.getValues(e.subjects[y],l).some(m=>m["@id"]===p)&&(f["@reverse"]=f["@reverse"]||{},M.addValue(f["@reverse"],l,[],{propertyIsArray:!0}),W.frame({...e,embedded:!0},[y],u,f["@reverse"][l],i))}xe(r,i,f),e.subjectStack.pop()}}};W.cleanupNull=(e,t)=>{if(S.isArray(e))return e.map(r=>W.cleanupNull(r,t)).filter(r=>r);if(e==="@null")return null;if(S.isObject(e)){if("@id"in e){const n=e["@id"];if(t.link.hasOwnProperty(n)){const r=t.link[n].indexOf(e);if(r!==-1)return t.link[n][r];t.link[n].push(e)}else t.link[n]=[e]}for(const n in e)e[n]=W.cleanupNull(e[n],t)}return e};function On(e){const t={};for(const n in e)e[n]!==void 0&&(t["@"+n]=[e[n]]);return[t]}function ti(e,t,n){for(let r=n.length-1;r>=0;--r){const i=n[r];if(i.graph===t&&i.subject["@id"]===e["@id"])return!0}return!1}function Ce(e,t,n){const r="@"+n;let i=r in e?e[r][0]:t[n];if(n==="embed"){if(i===!0)i="@once";else if(i===!1)i="@never";else if(i!=="@always"&&i!=="@never"&&i!=="@link"&&i!=="@first"&&i!=="@last"&&i!=="@once")throw new Qe("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{code:"invalid @embed value",frame:e})}return i}function ir(e){if(!S.isArray(e)||e.length!==1||!S.isObject(e[0]))throw new Qe("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{frame:e});if("@id"in e[0]){for(const t of M.asArray(e[0]["@id"]))if(!(S.isObject(t)||Dn.isAbsolute(t))||S.isString(t)&&t.indexOf("_:")===0)throw new Qe("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}if("@type"in e[0]){for(const t of M.asArray(e[0]["@type"]))if(!(S.isObject(t)||Dn.isAbsolute(t)||t==="@json")||S.isString(t)&&t.indexOf("_:")===0)throw new Qe("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{code:"invalid frame",frame:e})}}function ni(e,t,n,r){const i={};for(const a of t){const s=e.graphMap[e.graph][a];ar(e,s,n,r)&&(i[a]=s)}return i}function ar(e,t,n,r){let i=!0,a=!1;for(const s in n){let o=!1;const c=M.getValues(t,s),d=M.getValues(n,s).length===0;if(s==="@id"){if(S.isEmptyObject(n["@id"][0]||{})?o=!0:n["@id"].length>=0&&(o=n["@id"].includes(c[0])),!r.requireAll)return o}else if(s==="@type"){if(i=!1,d){if(c.length>0)return!1;o=!0}else if(n["@type"].length===1&&S.isEmptyObject(n["@type"][0]))o=c.length>0;else for(const p of n["@type"])S.isObject(p)&&"@default"in p?o=!0:o=o||c.some(h=>h===p);if(!r.requireAll)return o}else{if(Qt(s))continue;{const p=M.getValues(n,s)[0];let h=!1;if(p&&(ir([p]),h="@default"in p),i=!1,c.length===0&&h)continue;if(c.length>0&&d)return!1;if(p===void 0){if(c.length>0)return!1;o=!0}else if(Q.isList(p)){const f=p["@list"][0];if(Q.isList(c[0])){const l=c[0]["@list"];Q.isValue(f)?o=l.some(u=>Kt(f,u)):(Q.isSubject(f)||Q.isSubjectReference(f))&&(o=l.some(u=>Rn(e,f,u,r)))}}else Q.isValue(p)?o=c.some(f=>Kt(p,f)):Q.isSubjectReference(p)?o=c.some(f=>Rn(e,p,f,r)):S.isObject(p)?o=c.length>0:o=!1}}if(!o&&r.requireAll)return!1;a=a||o}return i||a}function ri(e,t){const n=e.uniqueEmbeds[e.graph],r=n[t],i=r.parent,a=r.property,s={"@id":t};if(S.isArray(i)){for(let c=0;c<i.length;++c)if(M.compareValues(i[c],s)){i[c]=s;break}}else{const c=S.isArray(i[a]);M.removeValue(i,a,s,{propertyIsArray:c}),M.addValue(i,a,s,{propertyIsArray:c})}const o=c=>{const d=Object.keys(n);for(const p of d)p in n&&S.isObject(n[p].parent)&&n[p].parent["@id"]===c&&(delete n[p],o(p))};o(t)}/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */function ct(e,t){if(S.isArray(e))return e.map(n=>ct(n,t));if(S.isObject(e)){// remove @preserve
if("@preserve"in e)return e["@preserve"][0];if(Q.isValue(e))return e;if(Q.isList(e))return e["@list"]=ct(e["@list"],t),e;if("@id"in e){const n=e["@id"];if(t.link.hasOwnProperty(n)){const r=t.link[n].indexOf(e);if(r!==-1)return t.link[n][r];t.link[n].push(e)}else t.link[n]=[e]}for(const n in e){if(n==="@id"&&t.bnodesToClear.includes(e[n])){delete e["@id"];continue}e[n]=ct(e[n],t)}}return e}function xe(e,t,n){S.isObject(e)?M.addValue(e,t,n,{propertyIsArray:!0}):e.push(n)}function Rn(e,t,n,r){if(!("@id"in n))return!1;const i=e.subjects[n["@id"]];return i&&ar(e,i,t,r)}function Kt(e,t){const n=t["@value"],r=t["@type"],i=t["@language"],a=e["@value"]?S.isArray(e["@value"])?e["@value"]:[e["@value"]]:[],s=e["@type"]?S.isArray(e["@type"])?e["@type"]:[e["@type"]]:[],o=e["@language"]?S.isArray(e["@language"])?e["@language"]:[e["@language"]]:[];return a.length===0&&s.length===0&&o.length===0?!0:!(!(a.includes(n)||S.isEmptyObject(a[0]))||!(!r&&s.length===0||s.includes(r)||r&&S.isEmptyObject(s[0]))||!(!i&&o.length===0||o.includes(i)||i&&S.isEmptyObject(o[0])))}const rn=C,{isArray:ge,isObject:be,isString:or,isUndefined:Tt}=z,{isList:Wt,isValue:fe,isGraph:lr,isSimpleGraph:Ln,isSubjectReference:kt}=pe,{expandIri:cr,getContextValue:H,isKeyword:dr,process:Mt,processingMode:si}=Re,{removeBase:An,prependBase:ii}=we,{REGEX_KEYWORD:ai,addValue:U,asArray:et,compareShortestLeast:oi}=ee,N={};var li=N;N.compact=async({activeCtx:e,activeProperty:t=null,element:n,options:r={}})=>{if(ge(n)){let a=[];for(let s=0;s<n.length;++s){const o=await N.compact({activeCtx:e,activeProperty:t,element:n[s],options:r});o!==null&&a.push(o)}return r.compactArrays&&a.length===1&&(H(e,t,"@container")||[]).length===0&&(a=a[0]),a}const i=H(e,t,"@context");if(Tt(i)||(e=await Mt({activeCtx:e,localCtx:i,propagate:!0,overrideProtected:!0,options:r})),be(n)){if(r.link&&"@id"in n&&r.link.hasOwnProperty(n["@id"])){const f=r.link[n["@id"]];for(let l=0;l<f.length;++l)if(f[l].expanded===n)return f[l].compacted}if(fe(n)||kt(n)){const f=N.compactValue({activeCtx:e,activeProperty:t,value:n,options:r});return r.link&&kt(n)&&(r.link.hasOwnProperty(n["@id"])||(r.link[n["@id"]]=[]),r.link[n["@id"]].push({expanded:n,compacted:f})),f}if(Wt(n)&&(H(e,t,"@container")||[]).includes("@list"))return N.compact({activeCtx:e,activeProperty:t,element:n["@list"],options:r});const a=t==="@reverse",s={},o=e;!fe(n)&&!kt(n)&&(e=e.revertToPreviousContext());const c=H(o,t,"@context");Tt(c)||(e=await Mt({activeCtx:e,localCtx:c,propagate:!0,overrideProtected:!0,options:r})),r.link&&"@id"in n&&(r.link.hasOwnProperty(n["@id"])||(r.link[n["@id"]]=[]),r.link[n["@id"]].push({expanded:n,compacted:s}));let d=n["@type"]||[];d.length>1&&(d=Array.from(d).sort());const p=e;for(const f of d){const l=N.compactIri({activeCtx:p,iri:f,relativeTo:{vocab:!0}}),u=H(o,l,"@context");Tt(u)||(e=await Mt({activeCtx:e,localCtx:u,options:r,propagate:!1}))}const h=Object.keys(n).sort();for(const f of h){const l=n[f];if(f==="@id"){let u=et(l).map(g=>N.compactIri({activeCtx:e,iri:g,relativeTo:{vocab:!1},base:r.base}));u.length===1&&(u=u[0]);const y=N.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}});s[y]=u;continue}if(f==="@type"){let u=et(l).map(I=>N.compactIri({activeCtx:o,iri:I,relativeTo:{vocab:!0}}));u.length===1&&(u=u[0]);const y=N.compactIri({activeCtx:e,iri:"@type",relativeTo:{vocab:!0}}),v=(H(e,y,"@container")||[]).includes("@set")&&si(e,1.1)||ge(u)&&l.length===0;U(s,y,u,{propertyIsArray:v});continue}if(f==="@reverse"){const u=await N.compact({activeCtx:e,activeProperty:"@reverse",element:l,options:r});for(const y in u)if(e.mappings.has(y)&&e.mappings.get(y).reverse){const g=u[y],v=(H(e,y,"@container")||[]).includes("@set")||!r.compactArrays;U(s,y,g,{propertyIsArray:v}),delete u[y]}if(Object.keys(u).length>0){const y=N.compactIri({activeCtx:e,iri:f,relativeTo:{vocab:!0}});U(s,y,u)}continue}if(f==="@preserve"){const u=await N.compact({activeCtx:e,activeProperty:t,element:l,options:r});ge(u)&&u.length===0||U(s,f,u);continue}if(f==="@index"){if((H(e,t,"@container")||[]).includes("@index"))continue;const y=N.compactIri({activeCtx:e,iri:f,relativeTo:{vocab:!0}});U(s,y,l);continue}if(f!=="@graph"&&f!=="@list"&&f!=="@included"&&dr(f)){const u=N.compactIri({activeCtx:e,iri:f,relativeTo:{vocab:!0}});U(s,u,l);continue}if(!ge(l))throw new rn("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");if(l.length===0){const u=N.compactIri({activeCtx:e,iri:f,value:l,relativeTo:{vocab:!0},reverse:a}),y=e.mappings.has(u)?e.mappings.get(u)["@nest"]:null;let g=s;y&&(Tn(e,y,r),be(s[y])||(s[y]={}),g=s[y]),U(g,u,l,{propertyIsArray:!0})}for(const u of l){const y=N.compactIri({activeCtx:e,iri:f,value:u,relativeTo:{vocab:!0},reverse:a}),g=e.mappings.has(y)?e.mappings.get(y)["@nest"]:null;let m=s;g&&(Tn(e,g,r),be(s[g])||(s[g]={}),m=s[g]);const v=H(e,y,"@container")||[],I=lr(u),b=Wt(u);let x;b?x=u["@list"]:I&&(x=u["@graph"]);let w=await N.compact({activeCtx:e,activeProperty:y,element:b||I?x:u,options:r});if(b)if(ge(w)||(w=[w]),!v.includes("@list"))w={[N.compactIri({activeCtx:e,iri:"@list",relativeTo:{vocab:!0}})]:w},"@index"in u&&(w[N.compactIri({activeCtx:e,iri:"@index",relativeTo:{vocab:!0}})]=u["@index"]);else{U(m,y,w,{valueIsArray:!0,allowDuplicate:!0});continue}if(I)if(v.includes("@graph")&&(v.includes("@id")||v.includes("@index")&&Ln(u))){let T;m.hasOwnProperty(y)?T=m[y]:m[y]=T={};const D=(v.includes("@id")?u["@id"]:u["@index"])||N.compactIri({activeCtx:e,iri:"@none",relativeTo:{vocab:!0}});U(T,D,w,{propertyIsArray:!r.compactArrays||v.includes("@set")})}else v.includes("@graph")&&Ln(u)?(ge(w)&&w.length>1&&(w={"@included":w}),U(m,y,w,{propertyIsArray:!r.compactArrays||v.includes("@set")})):(ge(w)&&w.length===1&&r.compactArrays&&(w=w[0]),w={[N.compactIri({activeCtx:e,iri:"@graph",relativeTo:{vocab:!0}})]:w},"@id"in u&&(w[N.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}})]=u["@id"]),"@index"in u&&(w[N.compactIri({activeCtx:e,iri:"@index",relativeTo:{vocab:!0}})]=u["@index"]),U(m,y,w,{propertyIsArray:!r.compactArrays||v.includes("@set")}));else if(v.includes("@language")||v.includes("@index")||v.includes("@id")||v.includes("@type")){let T;m.hasOwnProperty(y)?T=m[y]:m[y]=T={};let D;if(v.includes("@language"))fe(w)&&(w=w["@value"]),D=u["@language"];else if(v.includes("@index")){const A=H(e,y,"@index")||"@index",Le=N.compactIri({activeCtx:e,iri:A,relativeTo:{vocab:!0}});if(A==="@index")D=u["@index"],delete w[Le];else{let Ye;if([D,...Ye]=et(w[A]||[]),!or(D))D=null;else switch(Ye.length){case 0:delete w[A];break;case 1:w[A]=Ye[0];break;default:w[A]=Ye;break}}}else if(v.includes("@id")){const A=N.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}});D=w[A],delete w[A]}else if(v.includes("@type")){const A=N.compactIri({activeCtx:e,iri:"@type",relativeTo:{vocab:!0}});let Le;switch([D,...Le]=et(w[A]||[]),Le.length){case 0:delete w[A];break;case 1:w[A]=Le[0];break;default:w[A]=Le;break}Object.keys(w).length===1&&"@id"in u&&(w=await N.compact({activeCtx:e,activeProperty:y,element:{"@id":u["@id"]},options:r}))}D||(D=N.compactIri({activeCtx:e,iri:"@none",relativeTo:{vocab:!0}})),U(T,D,w,{propertyIsArray:v.includes("@set")})}else{const T=!r.compactArrays||v.includes("@set")||v.includes("@list")||ge(w)&&w.length===0||f==="@list"||f==="@graph";U(m,y,w,{propertyIsArray:T})}}}return s}return n};N.compactIri=({activeCtx:e,iri:t,value:n=null,relativeTo:r={vocab:!1},reverse:i=!1,base:a=null})=>{if(t===null)return t;e.isPropertyTermScoped&&e.previousContext&&(e=e.previousContext);const s=e.getInverse();if(dr(t)&&t in s&&"@none"in s[t]&&"@type"in s[t]["@none"]&&"@none"in s[t]["@none"]["@type"])return s[t]["@none"]["@type"]["@none"];if(r.vocab&&t in s){const h=e["@language"]||"@none",f=[];be(n)&&"@index"in n&&!("@graph"in n)&&f.push("@index","@index@set"),be(n)&&"@preserve"in n&&(n=n["@preserve"][0]),lr(n)?("@index"in n&&f.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in n&&f.push("@graph@id","@graph@id@set"),f.push("@graph","@graph@set","@set"),"@index"in n||f.push("@graph@index","@graph@index@set","@index","@index@set"),"@id"in n||f.push("@graph@id","@graph@id@set")):be(n)&&!fe(n)&&f.push("@id","@id@set","@type","@set@type");let l="@language",u="@null";if(i)l="@type",u="@reverse",f.push("@set");else if(Wt(n)){"@index"in n||f.push("@list");const g=n["@list"];if(g.length===0)l="@any",u="@none";else{let m=g.length===0?h:null,v=null;for(let I=0;I<g.length;++I){const b=g[I];let x="@none",w="@none";if(fe(b))if("@direction"in b){const T=(b["@language"]||"").toLowerCase(),D=b["@direction"];x=`${T}_${D}`}else"@language"in b?x=b["@language"].toLowerCase():"@type"in b?w=b["@type"]:x="@null";else w="@id";if(m===null?m=x:x!==m&&fe(b)&&(m="@none"),v===null?v=w:w!==v&&(v="@none"),m==="@none"&&v==="@none")break}m=m||"@none",v=v||"@none",v!=="@none"?(l="@type",u=v):u=m}}else{if(fe(n))if("@language"in n&&!("@index"in n)){f.push("@language","@language@set"),u=n["@language"];const g=n["@direction"];g&&(u=`${u}_${g}`)}else"@direction"in n&&!("@index"in n)?u=`_${n["@direction"]}`:"@type"in n&&(l="@type",u=n["@type"]);else l="@type",u="@id";f.push("@set")}f.push("@none"),be(n)&&!("@index"in n)&&f.push("@index","@index@set"),fe(n)&&Object.keys(n).length===1&&f.push("@language","@language@set");const y=ci(e,t,n,f,l,u);if(y!==null)return y}if(r.vocab&&"@vocab"in e){const h=e["@vocab"];if(t.indexOf(h)===0&&t!==h){const f=t.substr(h.length);if(!e.mappings.has(f))return f}}let o=null;const c=[];let d=e.fastCurieMap;const p=t.length-1;for(let h=0;h<p&&t[h]in d;++h)d=d[t[h]],""in d&&c.push(d[""][0]);for(let h=c.length-1;h>=0;--h){const f=c[h],l=f.terms;for(const u of l){const y=u+":"+t.substr(f.iri.length);e.mappings.get(u)._prefix&&(!e.mappings.has(y)||n===null&&e.mappings.get(y)["@id"]===t)&&(o===null||oi(y,o)<0)&&(o=y)}}if(o!==null)return o;for(const[h,f]of e.mappings)if(f&&f._prefix&&t.startsWith(h+":"))throw new rn(`Absolute IRI "${t}" confused with prefix "${h}".`,"jsonld.SyntaxError",{code:"IRI confused with prefix",context:e});if(!r.vocab)if("@base"in e)if(e["@base"]){const h=An(ii(a,e["@base"]),t);return ai.test(h)?`./${h}`:h}else return t;else return An(a,t);return t};N.compactValue=({activeCtx:e,activeProperty:t,value:n,options:r})=>{if(fe(n)){const o=H(e,t,"@type"),c=H(e,t,"@language"),d=H(e,t,"@direction"),p=H(e,t,"@container")||[],h="@index"in n&&!p.includes("@index");if(!h&&o!=="@none"&&(n["@type"]===o||"@language"in n&&n["@language"]===c&&"@direction"in n&&n["@direction"]===d||"@language"in n&&n["@language"]===c||"@direction"in n&&n["@direction"]===d))return n["@value"];const f=Object.keys(n).length,l=f===1||f===2&&"@index"in n&&!h,u="@language"in e,y=or(n["@value"]),g=e.mappings.has(t)&&e.mappings.get(t)["@language"]===null;if(l&&o!=="@none"&&(!u||!y||g))return n["@value"];const m={};return h&&(m[N.compactIri({activeCtx:e,iri:"@index",relativeTo:{vocab:!0}})]=n["@index"]),"@type"in n?m[N.compactIri({activeCtx:e,iri:"@type",relativeTo:{vocab:!0}})]=N.compactIri({activeCtx:e,iri:n["@type"],relativeTo:{vocab:!0}}):"@language"in n&&(m[N.compactIri({activeCtx:e,iri:"@language",relativeTo:{vocab:!0}})]=n["@language"]),"@direction"in n&&(m[N.compactIri({activeCtx:e,iri:"@direction",relativeTo:{vocab:!0}})]=n["@direction"]),m[N.compactIri({activeCtx:e,iri:"@value",relativeTo:{vocab:!0}})]=n["@value"],m}const i=cr(e,t,{vocab:!0},r),a=H(e,t,"@type"),s=N.compactIri({activeCtx:e,iri:n["@id"],relativeTo:{vocab:a==="@vocab"},base:r.base});return a==="@id"||a==="@vocab"||i==="@graph"?s:{[N.compactIri({activeCtx:e,iri:"@id",relativeTo:{vocab:!0}})]:s}};function ci(e,t,n,r,i,a){a===null&&(a="@null");const s=[];if((a==="@id"||a==="@reverse")&&be(n)&&"@id"in n){a==="@reverse"&&s.push("@reverse");const c=N.compactIri({activeCtx:e,iri:n["@id"],relativeTo:{vocab:!0}});e.mappings.has(c)&&e.mappings.get(c)&&e.mappings.get(c)["@id"]===n["@id"]?s.push.apply(s,["@vocab","@id"]):s.push.apply(s,["@id","@vocab"])}else{s.push(a);const c=s.find(d=>d.includes("_"));c&&s.push(c.replace(/^[^_]+_/,"_"))}s.push("@none");const o=e.inverse[t];for(const c of r){if(!(c in o))continue;const d=o[c][i];for(const p of s)if(p in d)return d[p]}return null}function Tn(e,t,n){if(cr(e,t,{vocab:!0},n)!=="@nest")throw new rn("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{code:"invalid @nest value"})}var $t,kn;function di(){return kn||(kn=1,$t=e=>{class t{toString(){return"[object JsonLdProcessor]"}}return Object.defineProperty(t,"prototype",{writable:!1,enumerable:!1}),Object.defineProperty(t.prototype,"constructor",{writable:!0,enumerable:!1,configurable:!0,value:t}),t.compact=function(n,r){return arguments.length<2?Promise.reject(new TypeError("Could not compact, too few arguments.")):e.compact(n,r)},t.expand=function(n){return arguments.length<1?Promise.reject(new TypeError("Could not expand, too few arguments.")):e.expand(n)},t.flatten=function(n){return arguments.length<1?Promise.reject(new TypeError("Could not flatten, too few arguments.")):e.flatten(n)},t}),$t}/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2022 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */const Mn=Ct,$n=Wr,ye=ee,ce=cs,Jt=ye.IdentifierIssuer,ie=C,ui=zn,tt=us,{expand:fi}=Ns,{flatten:hi}=Os,{fromRDF:pi}=Ts,{toRDF:gi}=Ks,{frameMergedOrDefault:yi,cleanupNull:mi}=ei,{isArray:Te,isObject:Ee,isString:ae}=z,{isSubjectReference:vi}=pe,{expandIri:bi,getInitialContext:nt,process:Jn,processingMode:Ft}=Re,{compact:wi,compactIri:Ii}=li,{createNodeMap:xi,createMergedNodeMap:Ei,mergeNodeMaps:Ni}=yt,{logEventHandler:_i,logWarningEventHandler:ji,safeEventHandler:Si,setDefaultEventHandler:Di,setupEventHandler:Oi,strictEventHandler:Ri,unhandledEventHandler:Li}=We,ur=function(e){const t={},r=new ui({max:100});e.compact=async function(a,s,o){if(arguments.length<2)throw new TypeError("Could not compact, too few arguments.");if(s===null)throw new ie("The compaction context must not be null.","jsonld.CompactError",{code:"invalid local context"});if(a===null)return null;o=i(o,{base:ae(a)?a:"",compactArrays:!0,compactToRelative:!0,graph:!1,skipExpansion:!1,link:!1,issuer:new Jt("_:b"),contextResolver:new ce({sharedCache:r})}),o.link&&(o.skipExpansion=!0),o.compactToRelative||delete o.base;let c;o.skipExpansion?c=a:c=await e.expand(a,o);const d=await e.processContext(nt(o),s,o);let p=await wi({activeCtx:d,element:c,options:o});o.compactArrays&&!o.graph&&Te(p)?p.length===1?p=p[0]:p.length===0&&(p={}):o.graph&&Ee(p)&&(p=[p]),Ee(s)&&"@context"in s&&(s=s["@context"]),s=ye.clone(s),Te(s)||(s=[s]);const h=s;s=[];for(let l=0;l<h.length;++l)(!Ee(h[l])||Object.keys(h[l]).length>0)&&s.push(h[l]);const f=s.length>0;if(s.length===1&&(s=s[0]),Te(p)){const l=Ii({activeCtx:d,iri:"@graph",relativeTo:{vocab:!0}}),u=p;p={},f&&(p["@context"]=s),p[l]=u}else if(Ee(p)&&f){const l=p;p={"@context":s};for(const u in l)p[u]=l[u]}return p},e.expand=async function(a,s){if(arguments.length<1)throw new TypeError("Could not expand, too few arguments.");s=i(s,{keepFreeFloatingNodes:!1,contextResolver:new ce({sharedCache:r})});const o={},c=[];if("expandContext"in s){const f=ye.clone(s.expandContext);Ee(f)&&"@context"in f?o.expandContext=f:o.expandContext={"@context":f},c.push(o.expandContext)}let d;if(!ae(a))o.input=ye.clone(a);else{const f=await e.get(a,s);d=f.documentUrl,o.input=f.document,f.contextUrl&&(o.remoteContext={"@context":f.contextUrl},c.push(o.remoteContext))}"base"in s||(s.base=d||"");let p=nt(s);for(const f of c)p=await Jn({activeCtx:p,localCtx:f,options:s});let h=await fi({activeCtx:p,element:o.input,options:s});return Ee(h)&&"@graph"in h&&Object.keys(h).length===1?h=h["@graph"]:h===null&&(h=[]),Te(h)||(h=[h]),h},e.flatten=async function(a,s,o){if(arguments.length<1)return new TypeError("Could not flatten, too few arguments.");typeof s=="function"?s=null:s=s||null,o=i(o,{base:ae(a)?a:"",contextResolver:new ce({sharedCache:r})});const c=await e.expand(a,o),d=hi(c);return s===null?d:(o.graph=!0,o.skipExpansion=!0,await e.compact(d,s,o))},e.frame=async function(a,s,o){if(arguments.length<2)throw new TypeError("Could not frame, too few arguments.");if(o=i(o,{base:ae(a)?a:"",embed:"@once",explicit:!1,requireAll:!1,omitDefault:!1,bnodesToClear:[],contextResolver:new ce({sharedCache:r})}),ae(s)){const g=await e.get(s,o);if(s=g.document,g.contextUrl){let m=s["@context"];m?Te(m)?m.push(g.contextUrl):m=[m,g.contextUrl]:m=g.contextUrl,s["@context"]=m}}const c=s?s["@context"]||{}:{},d=await e.processContext(nt(o),c,o);o.hasOwnProperty("omitGraph")||(o.omitGraph=Ft(d,1.1)),o.hasOwnProperty("pruneBlankNodeIdentifiers")||(o.pruneBlankNodeIdentifiers=Ft(d,1.1));const p=await e.expand(a,o),h={...o};h.isFrame=!0,h.keepFreeFloatingNodes=!0;const f=await e.expand(s,h),l=Object.keys(s).map(g=>bi(d,g,{vocab:!0}));h.merged=!l.includes("@graph"),h.is11=Ft(d,1.1);const u=yi(p,f,h);h.graph=!o.omitGraph,h.skipExpansion=!0,h.link={},h.framing=!0;let y=await e.compact(u,c,h);return h.link={},y=mi(y,h),y},e.link=async function(a,s,o){const c={};return s&&(c["@context"]=s),c["@embed"]="@link",e.frame(a,c,o)},e.normalize=e.canonize=async function(a,s){if(arguments.length<1)throw new TypeError("Could not canonize, too few arguments.");if(s=i(s,{base:ae(a)?a:null,algorithm:"URDNA2015",skipExpansion:!1,safe:!0,contextResolver:new ce({sharedCache:r})}),"inputFormat"in s){if(s.inputFormat!=="application/n-quads"&&s.inputFormat!=="application/nquads")throw new ie("Unknown canonicalization input format.","jsonld.CanonizeError");const d=tt.parse(a);return Mn.canonize(d,s)}const o={...s};delete o.format,o.produceGeneralizedRdf=!1;const c=await e.toRDF(a,o);return Mn.canonize(c,s)},e.fromRDF=async function(a,s){if(arguments.length<1)throw new TypeError("Could not convert from RDF, too few arguments.");s=i(s,{format:ae(a)?"application/n-quads":void 0});const{format:o}=s;let{rdfParser:c}=s;if(o){if(c=c||t[o],!c)throw new ie("Unknown input format.","jsonld.UnknownFormat",{format:o})}else c=()=>a;const d=await c(a);return pi(d,s)},e.toRDF=async function(a,s){if(arguments.length<1)throw new TypeError("Could not convert to RDF, too few arguments.");s=i(s,{base:ae(a)?a:"",skipExpansion:!1,contextResolver:new ce({sharedCache:r})});let o;s.skipExpansion?o=a:o=await e.expand(a,s);const c=gi(o,s);if(s.format){if(s.format==="application/n-quads"||s.format==="application/nquads")return tt.serialize(c);throw new ie("Unknown output format.","jsonld.UnknownFormat",{format:s.format})}return c},e.createNodeMap=async function(a,s){if(arguments.length<1)throw new TypeError("Could not create node map, too few arguments.");s=i(s,{base:ae(a)?a:"",contextResolver:new ce({sharedCache:r})});const o=await e.expand(a,s);return Ei(o,s)},e.merge=async function(a,s,o){if(arguments.length<1)throw new TypeError("Could not merge, too few arguments.");if(!Te(a))throw new TypeError('Could not merge, "docs" must be an array.');typeof s=="function"?s=null:s=s||null,o=i(o,{contextResolver:new ce({sharedCache:r})});const c=await Promise.all(a.map(g=>{const m={...o};return e.expand(g,m)}));let d=!0;"mergeNodes"in o&&(d=o.mergeNodes);const p=o.issuer||new Jt("_:b"),h={"@default":{}};for(let g=0;g<c.length;++g){const m=ye.relabelBlankNodes(c[g],{issuer:new Jt("_:b"+g+"-")}),v=d||g===0?h:{"@default":{}};if(xi(m,v,"@default",p),v!==h)for(const I in v){const b=v[I];if(!(I in h)){h[I]=b;continue}const x=h[I];for(const w in b)w in x||(x[w]=b[w])}}const f=Ni(h),l=[],u=Object.keys(f).sort();for(let g=0;g<u.length;++g){const m=f[u[g]];vi(m)||l.push(m)}return s===null?l:(o.graph=!0,o.skipExpansion=!0,await e.compact(l,s,o))},Object.defineProperty(e,"documentLoader",{get:()=>e._documentLoader,set:a=>e._documentLoader=a}),e.documentLoader=async a=>{throw new ie("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{code:"loading document failed",url:a})},e.get=async function(a,s){let o;typeof s.documentLoader=="function"?o=s.documentLoader:o=e.documentLoader;const c=await o(a);try{if(!c.document)throw new ie("No remote document found at the given URL.","jsonld.NullRemoteDocument");ae(c.document)&&(c.document=JSON.parse(c.document))}catch(d){throw new ie("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{code:"loading document failed",cause:d,remoteDoc:c})}return c},e.processContext=async function(a,s,o){return o=i(o,{base:"",contextResolver:new ce({sharedCache:r})}),s===null?nt(o):(s=ye.clone(s),Ee(s)&&"@context"in s||(s={"@context":s}),Jn({activeCtx:a,localCtx:s,options:o}))},e.getContextValue=Re.getContextValue,e.documentLoaders={},e.useDocumentLoader=function(a){if(!(a in e.documentLoaders))throw new ie('Unknown document loader type: "'+a+'"',"jsonld.UnknownDocumentLoader",{type:a});e.documentLoader=e.documentLoaders[a].apply(e,Array.prototype.slice.call(arguments,1))},e.registerRDFParser=function(a,s){t[a]=s},e.unregisterRDFParser=function(a){delete t[a]},e.registerRDFParser("application/n-quads",tt.parse),e.registerRDFParser("application/nquads",tt.parse),e.url=we,e.logEventHandler=_i,e.logWarningEventHandler=ji,e.safeEventHandler=Si,e.setDefaultEventHandler=Di,e.strictEventHandler=Ri,e.unhandledEventHandler=Li,e.util=ye,Object.assign(e,ye),e.promises=e,e.RequestQueue=Vn(),e.JsonLdProcessor=di()(e),$n.setupGlobals(e),$n.setupDocumentLoaders(e);function i(a,{documentLoader:s=e.documentLoader,...o}){if(a&&"compactionMap"in a)throw new ie('"compactionMap" not supported.',"jsonld.OptionsError");if(a&&"expansionMap"in a)throw new ie('"expansionMap" not supported.',"jsonld.OptionsError");return Object.assign({},{documentLoader:s},o,a,{eventHandler:Oi({options:a})})}return e},sn=function(){return ur(function(){return sn()})};ur(sn);var fr=sn;const Ai=hr(fr),Gi=gr({__proto__:null,default:Ai},[fr]);export{Gi as j};
